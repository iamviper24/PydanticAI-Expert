PydanticAI
pydantic/pydantic-ai
Introduction
Installation
Getting Help
Contributing
Troubleshooting
Upgrade Guide
Documentation
Documentation
Agents
Models
Models
OpenAI
Anthropic
Gemini
Google
Bedrock
Cohere
Groq
Mistral
Dependencies
Function Tools
Common Tools
Output
Messages and chat history
Unit testing
Debugging and Monitoring
Multi-agent Applications
Graphs
Evals
Image, Audio, Video & Document Input
Thinking
Direct Model Requests
MCP
MCP
Client
Server
MCP Run Python
A2A
Command Line Interface (CLI)
Examples
Examples
Pydantic Model
Weather agent
Bank support
SQL Generation
Flight booking
RAG
Stream markdown
Stream whales
Chat App with FastAPI
Question Graph
Slack Lead Qualifier with Modal
API Reference
API Reference
pydantic_ai.agent
pydantic_ai.tools
pydantic_ai.common_tools
pydantic_ai.output
pydantic_ai.result
pydantic_ai.messages
pydantic_ai.exceptions
pydantic_ai.settings
pydantic_ai.usage
pydantic_ai.mcp
pydantic_ai.format_as_xml
pydantic_ai.format_prompt
pydantic_ai.direct
pydantic_ai.direct
Table of contents
direct
model_request
model_request_sync
model_request_stream
model_request_stream_sync
StreamedResponseSync
__iter__
get
usage
model_name
timestamp
pydantic_ai.models
pydantic_ai.models.openai
pydantic_ai.models.anthropic
pydantic_ai.models.bedrock
pydantic_ai.models.cohere
pydantic_ai.models.gemini
pydantic_ai.models.google
pydantic_ai.models.groq
pydantic_ai.models.instrumented
pydantic_ai.models.mistral
pydantic_ai.models.test
pydantic_ai.models.function
pydantic_ai.models.fallback
pydantic_ai.models.wrapper
pydantic_ai.models.mcp_sampling
pydantic_ai.profiles
pydantic_ai.providers
pydantic_graph
pydantic_graph.nodes
pydantic_graph.persistence
pydantic_graph.mermaid
pydantic_graph.exceptions
pydantic_evals.dataset
pydantic_evals.evaluators
pydantic_evals.reporting
pydantic_evals.otel
pydantic_evals.generation
fasta2a
Table of contents
direct
model_request
model_request_sync
model_request_stream
model_request_stream_sync
StreamedResponseSync
__iter__
get
usage
model_name
timestamp
pydantic_ai.direct
Methods for making imperative requests to language models with minimal abstraction.
These methods allow you to make requests to LLMs where the only abstraction is input and output schema
translation so you can use all models with the same API.
These methods are thin wrappers around
Model
implementations.
model_request
async
model_request
(
model
:
Model
|
KnownModelName
|
str
,
messages
:
list
[
ModelMessage
],
*
,
model_settings
:
ModelSettings
|
None
=
None
,
model_request_parameters
:
(
ModelRequestParameters
|
None
)
=
None
,
instrument
:
InstrumentationSettings
|
bool
|
None
=
None
)
->
ModelResponse
Make a non-streamed request to a model.
model_request_example.py
from
pydantic_ai.direct
import
model_request
from
pydantic_ai.messages
import
ModelRequest
async
def
main
():
model_response
=
await
model_request
(
'anthropic:claude-3-5-haiku-latest'
,
[
ModelRequest
.
user_text_prompt
(
'What is the capital of France?'
)]
# (1)!
)
print
(
model_response
)
'''
ModelResponse(
parts=[TextPart(content='Paris')],
usage=Usage(requests=1, request_tokens=56, response_tokens=1, total_tokens=57),
model_name='claude-3-5-haiku-latest',
timestamp=datetime.datetime(...),
)
'''
See
ModelRequest.user_text_prompt
for details.
Parameters:
Name
Type
Description
Default
model
Model
|
KnownModelName
|
str
The model to make a request to. We allow
str
here since the actual list of allowed models changes frequently.
required
messages
list
[
ModelMessage
]
Messages to send to the model
required
model_settings
ModelSettings
| None
optional model settings
None
model_request_parameters
ModelRequestParameters
| None
optional model request parameters
None
instrument
InstrumentationSettings
|
bool
| None
Whether to instrument the request with OpenTelemetry/Logfire, if
None
the value from
logfire.instrument_pydantic_ai
is used.
None
Returns:
Type
Description
ModelResponse
The model response and token usage associated with the request.
Source code in
pydantic_ai_slim/pydantic_ai/direct.py
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
async
def
model_request
(
model
:
models
.
Model
|
models
.
KnownModelName
|
str
,
messages
:
list
[
messages
.
ModelMessage
],
*
,
model_settings
:
settings
.
ModelSettings
|
None
=
None
,
model_request_parameters
:
models
.
ModelRequestParameters
|
None
=
None
,
instrument
:
instrumented_models
.
InstrumentationSettings
|
bool
|
None
=
None
,
)
->
messages
.
ModelResponse
:
"""Make a non-streamed request to a model.
```py title="model_request_example.py"
from pydantic_ai.direct import model_request
from pydantic_ai.messages import ModelRequest
async def main():
model_response = await model_request(
'anthropic:claude-3-5-haiku-latest',
[ModelRequest.user_text_prompt('What is the capital of France?')]  # (1)!
)
print(model_response)
'''
ModelResponse(
parts=[TextPart(content='Paris')],
usage=Usage(requests=1, request_tokens=56, response_tokens=1, total_tokens=57),
model_name='claude-3-5-haiku-latest',
timestamp=datetime.datetime(...),
)
'''
```
1. See [`ModelRequest.user_text_prompt`][pydantic_ai.messages.ModelRequest.user_text_prompt] for details.
Args:
model: The model to make a request to. We allow `str` here since the actual list of allowed models changes frequently.
messages: Messages to send to the model
model_settings: optional model settings
model_request_parameters: optional model request parameters
instrument: Whether to instrument the request with OpenTelemetry/Logfire, if `None` the value from
[`logfire.instrument_pydantic_ai`][logfire.Logfire.instrument_pydantic_ai] is used.
Returns:
The model response and token usage associated with the request.
"""
model_instance
=
_prepare_model
(
model
,
instrument
)
return
await
model_instance
.
request
(
messages
,
model_settings
,
model_instance
.
customize_request_parameters
(
model_request_parameters
or
models
.
ModelRequestParameters
()),
)
model_request_sync
model_request_sync
(
model
:
Model
|
KnownModelName
|
str
,
messages
:
list
[
ModelMessage
],
*
,
model_settings
:
ModelSettings
|
None
=
None
,
model_request_parameters
:
(
ModelRequestParameters
|
None
)
=
None
,
instrument
:
InstrumentationSettings
|
bool
|
None
=
None
)
->
ModelResponse
Make a Synchronous, non-streamed request to a model.
This is a convenience method that wraps
model_request
with
loop.run_until_complete(...)
. You therefore can't use this method inside async code or if there's an active event loop.
model_request_sync_example.py
from
pydantic_ai.direct
import
model_request_sync
from
pydantic_ai.messages
import
ModelRequest
model_response
=
model_request_sync
(
'anthropic:claude-3-5-haiku-latest'
,
[
ModelRequest
.
user_text_prompt
(
'What is the capital of France?'
)]
# (1)!
)
print
(
model_response
)
'''
ModelResponse(
parts=[TextPart(content='Paris')],
usage=Usage(requests=1, request_tokens=56, response_tokens=1, total_tokens=57),
model_name='claude-3-5-haiku-latest',
timestamp=datetime.datetime(...),
)
'''
See
ModelRequest.user_text_prompt
for details.
Parameters:
Name
Type
Description
Default
model
Model
|
KnownModelName
|
str
The model to make a request to. We allow
str
here since the actual list of allowed models changes frequently.
required
messages
list
[
ModelMessage
]
Messages to send to the model
required
model_settings
ModelSettings
| None
optional model settings
None
model_request_parameters
ModelRequestParameters
| None
optional model request parameters
None
instrument
InstrumentationSettings
|
bool
| None
Whether to instrument the request with OpenTelemetry/Logfire, if
None
the value from
logfire.instrument_pydantic_ai
is used.
None
Returns:
Type
Description
ModelResponse
The model response and token usage associated with the request.
Source code in
pydantic_ai_slim/pydantic_ai/direct.py
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
def
model_request_sync
(
model
:
models
.
Model
|
models
.
KnownModelName
|
str
,
messages
:
list
[
messages
.
ModelMessage
],
*
,
model_settings
:
settings
.
ModelSettings
|
None
=
None
,
model_request_parameters
:
models
.
ModelRequestParameters
|
None
=
None
,
instrument
:
instrumented_models
.
InstrumentationSettings
|
bool
|
None
=
None
,
)
->
messages
.
ModelResponse
:
"""Make a Synchronous, non-streamed request to a model.
This is a convenience method that wraps [`model_request`][pydantic_ai.direct.model_request] with
`loop.run_until_complete(...)`. You therefore can't use this method inside async code or if there's an active event loop.
```py title="model_request_sync_example.py"
from pydantic_ai.direct import model_request_sync
from pydantic_ai.messages import ModelRequest
model_response = model_request_sync(
'anthropic:claude-3-5-haiku-latest',
[ModelRequest.user_text_prompt('What is the capital of France?')]  # (1)!
)
print(model_response)
'''
ModelResponse(
parts=[TextPart(content='Paris')],
usage=Usage(requests=1, request_tokens=56, response_tokens=1, total_tokens=57),
model_name='claude-3-5-haiku-latest',
timestamp=datetime.datetime(...),
)
'''
```
1. See [`ModelRequest.user_text_prompt`][pydantic_ai.messages.ModelRequest.user_text_prompt] for details.
Args:
model: The model to make a request to. We allow `str` here since the actual list of allowed models changes frequently.
messages: Messages to send to the model
model_settings: optional model settings
model_request_parameters: optional model request parameters
instrument: Whether to instrument the request with OpenTelemetry/Logfire, if `None` the value from
[`logfire.instrument_pydantic_ai`][logfire.Logfire.instrument_pydantic_ai] is used.
Returns:
The model response and token usage associated with the request.
"""
return
_get_event_loop
()
.
run_until_complete
(
model_request
(
model
,
messages
,
model_settings
=
model_settings
,
model_request_parameters
=
model_request_parameters
,
instrument
=
instrument
,
)
)
model_request_stream
model_request_stream
(
model
:
Model
|
KnownModelName
|
str
,
messages
:
list
[
ModelMessage
],
*
,
model_settings
:
ModelSettings
|
None
=
None
,
model_request_parameters
:
(
ModelRequestParameters
|
None
)
=
None
,
instrument
:
InstrumentationSettings
|
bool
|
None
=
None
)
->
AbstractAsyncContextManager
[
StreamedResponse
]
Make a streamed async request to a model.
model_request_stream_example.py
from
pydantic_ai.direct
import
model_request_stream
from
pydantic_ai.messages
import
ModelRequest
async
def
main
():
messages
=
[
ModelRequest
.
user_text_prompt
(
'Who was Albert Einstein?'
)]
# (1)!
async
with
model_request_stream
(
'openai:gpt-4.1-mini'
,
messages
)
as
stream
:
chunks
=
[]
async
for
chunk
in
stream
:
chunks
.
append
(
chunk
)
print
(
chunks
)
'''
[
PartStartEvent(index=0, part=TextPart(content='Albert Einstein was ')),
PartDeltaEvent(
index=0, delta=TextPartDelta(content_delta='a German-born theoretical ')
),
PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='physicist.')),
]
'''
See
ModelRequest.user_text_prompt
for details.
Parameters:
Name
Type
Description
Default
model
Model
|
KnownModelName
|
str
The model to make a request to. We allow
str
here since the actual list of allowed models changes frequently.
required
messages
list
[
ModelMessage
]
Messages to send to the model
required
model_settings
ModelSettings
| None
optional model settings
None
model_request_parameters
ModelRequestParameters
| None
optional model request parameters
None
instrument
InstrumentationSettings
|
bool
| None
Whether to instrument the request with OpenTelemetry/Logfire, if
None
the value from
logfire.instrument_pydantic_ai
is used.
None
Returns:
Type
Description
AbstractAsyncContextManager
[
StreamedResponse
]
A
stream response
async context manager.
Source code in
pydantic_ai_slim/pydantic_ai/direct.py
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
def
model_request_stream
(
model
:
models
.
Model
|
models
.
KnownModelName
|
str
,
messages
:
list
[
messages
.
ModelMessage
],
*
,
model_settings
:
settings
.
ModelSettings
|
None
=
None
,
model_request_parameters
:
models
.
ModelRequestParameters
|
None
=
None
,
instrument
:
instrumented_models
.
InstrumentationSettings
|
bool
|
None
=
None
,
)
->
AbstractAsyncContextManager
[
models
.
StreamedResponse
]:
"""Make a streamed async request to a model.
```py {title="model_request_stream_example.py"}
from pydantic_ai.direct import model_request_stream
from pydantic_ai.messages import ModelRequest
async def main():
messages = [ModelRequest.user_text_prompt('Who was Albert Einstein?')]  # (1)!
async with model_request_stream('openai:gpt-4.1-mini', messages) as stream:
chunks = []
async for chunk in stream:
chunks.append(chunk)
print(chunks)
'''
[
PartStartEvent(index=0, part=TextPart(content='Albert Einstein was ')),
PartDeltaEvent(
index=0, delta=TextPartDelta(content_delta='a German-born theoretical ')
),
PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='physicist.')),
]
'''
```
1. See [`ModelRequest.user_text_prompt`][pydantic_ai.messages.ModelRequest.user_text_prompt] for details.
Args:
model: The model to make a request to. We allow `str` here since the actual list of allowed models changes frequently.
messages: Messages to send to the model
model_settings: optional model settings
model_request_parameters: optional model request parameters
instrument: Whether to instrument the request with OpenTelemetry/Logfire, if `None` the value from
[`logfire.instrument_pydantic_ai`][logfire.Logfire.instrument_pydantic_ai] is used.
Returns:
A [stream response][pydantic_ai.models.StreamedResponse] async context manager.
"""
model_instance
=
_prepare_model
(
model
,
instrument
)
return
model_instance
.
request_stream
(
messages
,
model_settings
,
model_instance
.
customize_request_parameters
(
model_request_parameters
or
models
.
ModelRequestParameters
()),
)
model_request_stream_sync
model_request_stream_sync
(
model
:
Model
|
KnownModelName
|
str
,
messages
:
list
[
ModelMessage
],
*
,
model_settings
:
ModelSettings
|
None
=
None
,
model_request_parameters
:
(
ModelRequestParameters
|
None
)
=
None
,
instrument
:
InstrumentationSettings
|
bool
|
None
=
None
)
->
StreamedResponseSync
Make a streamed synchronous request to a model.
This is the synchronous version of
model_request_stream
.
It uses threading to run the asynchronous stream in the background while providing a synchronous iterator interface.
model_request_stream_sync_example.py
from
pydantic_ai.direct
import
model_request_stream_sync
from
pydantic_ai.messages
import
ModelRequest
messages
=
[
ModelRequest
.
user_text_prompt
(
'Who was Albert Einstein?'
)]
with
model_request_stream_sync
(
'openai:gpt-4.1-mini'
,
messages
)
as
stream
:
chunks
=
[]
for
chunk
in
stream
:
chunks
.
append
(
chunk
)
print
(
chunks
)
'''
[
PartStartEvent(index=0, part=TextPart(content='Albert Einstein was ')),
PartDeltaEvent(
index=0, delta=TextPartDelta(content_delta='a German-born theoretical ')
),
PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='physicist.')),
]
'''
Parameters:
Name
Type
Description
Default
model
Model
|
KnownModelName
|
str
The model to make a request to. We allow
str
here since the actual list of allowed models changes frequently.
required
messages
list
[
ModelMessage
]
Messages to send to the model
required
model_settings
ModelSettings
| None
optional model settings
None
model_request_parameters
ModelRequestParameters
| None
optional model request parameters
None
instrument
InstrumentationSettings
|
bool
| None
Whether to instrument the request with OpenTelemetry/Logfire, if
None
the value from
logfire.instrument_pydantic_ai
is used.
None
Returns:
Type
Description
StreamedResponseSync
A
sync stream response
context manager.
Source code in
pydantic_ai_slim/pydantic_ai/direct.py
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
def
model_request_stream_sync
(
model
:
models
.
Model
|
models
.
KnownModelName
|
str
,
messages
:
list
[
messages
.
ModelMessage
],
*
,
model_settings
:
settings
.
ModelSettings
|
None
=
None
,
model_request_parameters
:
models
.
ModelRequestParameters
|
None
=
None
,
instrument
:
instrumented_models
.
InstrumentationSettings
|
bool
|
None
=
None
,
)
->
StreamedResponseSync
:
"""Make a streamed synchronous request to a model.
This is the synchronous version of [`model_request_stream`][pydantic_ai.direct.model_request_stream].
It uses threading to run the asynchronous stream in the background while providing a synchronous iterator interface.
```py {title="model_request_stream_sync_example.py"}
from pydantic_ai.direct import model_request_stream_sync
from pydantic_ai.messages import ModelRequest
messages = [ModelRequest.user_text_prompt('Who was Albert Einstein?')]
with model_request_stream_sync('openai:gpt-4.1-mini', messages) as stream:
chunks = []
for chunk in stream:
chunks.append(chunk)
print(chunks)
'''
[
PartStartEvent(index=0, part=TextPart(content='Albert Einstein was ')),
PartDeltaEvent(
index=0, delta=TextPartDelta(content_delta='a German-born theoretical ')
),
PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='physicist.')),
]
'''
```
Args:
model: The model to make a request to. We allow `str` here since the actual list of allowed models changes frequently.
messages: Messages to send to the model
model_settings: optional model settings
model_request_parameters: optional model request parameters
instrument: Whether to instrument the request with OpenTelemetry/Logfire, if `None` the value from
[`logfire.instrument_pydantic_ai`][logfire.Logfire.instrument_pydantic_ai] is used.
Returns:
A [sync stream response][pydantic_ai.direct.StreamedResponseSync] context manager.
"""
async_stream_cm
=
model_request_stream
(
model
=
model
,
messages
=
messages
,
model_settings
=
model_settings
,
model_request_parameters
=
model_request_parameters
,
instrument
=
instrument
,
)
return
StreamedResponseSync
(
async_stream_cm
)
StreamedResponseSync
dataclass
Synchronous wrapper to async streaming responses by running the async producer in a background thread and providing a synchronous iterator.
This class must be used as a context manager with the
with
statement.
Source code in
pydantic_ai_slim/pydantic_ai/direct.py
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
@dataclass
class
StreamedResponseSync
:
"""Synchronous wrapper to async streaming responses by running the async producer in a background thread and providing a synchronous iterator.
This class must be used as a context manager with the `with` statement.
"""
_async_stream_cm
:
AbstractAsyncContextManager
[
StreamedResponse
]
_queue
:
queue
.
Queue
[
messages
.
ModelResponseStreamEvent
|
Exception
|
None
]
=
field
(
default_factory
=
queue
.
Queue
,
init
=
False
)
_thread
:
threading
.
Thread
|
None
=
field
(
default
=
None
,
init
=
False
)
_stream_response
:
StreamedResponse
|
None
=
field
(
default
=
None
,
init
=
False
)
_exception
:
Exception
|
None
=
field
(
default
=
None
,
init
=
False
)
_context_entered
:
bool
=
field
(
default
=
False
,
init
=
False
)
_stream_ready
:
threading
.
Event
=
field
(
default_factory
=
threading
.
Event
,
init
=
False
)
def
__enter__
(
self
)
->
StreamedResponseSync
:
self
.
_context_entered
=
True
self
.
_start_producer
()
return
self
def
__exit__
(
self
,
_exc_type
:
type
[
BaseException
]
|
None
,
_exc_val
:
BaseException
|
None
,
_exc_tb
:
TracebackType
|
None
,
)
->
None
:
self
.
_cleanup
()
def
__iter__
(
self
)
->
Iterator
[
messages
.
ModelResponseStreamEvent
]:
"""Stream the response as an iterable of [`ModelResponseStreamEvent`][pydantic_ai.messages.ModelResponseStreamEvent]s."""
self
.
_check_context_manager_usage
()
while
True
:
item
=
self
.
_queue
.
get
()
if
item
is
None
:
# End of stream
break
elif
isinstance
(
item
,
Exception
):
raise
item
else
:
yield
item
def
__repr__
(
self
)
->
str
:
if
self
.
_stream_response
:
return
repr
(
self
.
_stream_response
)
else
:
return
f
'
{
self
.
__class__
.
__name__
}
(context_entered=
{
self
.
_context_entered
}
)'
__str__
=
__repr__
def
_check_context_manager_usage
(
self
)
->
None
:
if
not
self
.
_context_entered
:
raise
RuntimeError
(
'StreamedResponseSync must be used as a context manager. '
'Use: `with model_request_stream_sync(...) as stream:`'
)
def
_ensure_stream_ready
(
self
)
->
StreamedResponse
:
self
.
_check_context_manager_usage
()
if
self
.
_stream_response
is
None
:
# Wait for the background thread to signal that the stream is ready
if
not
self
.
_stream_ready
.
wait
(
timeout
=
STREAM_INITIALIZATION_TIMEOUT
):
raise
RuntimeError
(
'Stream failed to initialize within timeout'
)
if
self
.
_stream_response
is
None
:
# pragma: no cover
raise
RuntimeError
(
'Stream failed to initialize'
)
return
self
.
_stream_response
def
_start_producer
(
self
):
self
.
_thread
=
threading
.
Thread
(
target
=
self
.
_async_producer
,
daemon
=
True
)
self
.
_thread
.
start
()
def
_async_producer
(
self
):
async
def
_consume_async_stream
():
try
:
async
with
self
.
_async_stream_cm
as
stream
:
self
.
_stream_response
=
stream
# Signal that the stream is ready
self
.
_stream_ready
.
set
()
async
for
event
in
stream
:
self
.
_queue
.
put
(
event
)
except
Exception
as
e
:
# Signal ready even on error so waiting threads don't hang
self
.
_stream_ready
.
set
()
self
.
_queue
.
put
(
e
)
finally
:
self
.
_queue
.
put
(
None
)
# Signal end
_get_event_loop
()
.
run_until_complete
(
_consume_async_stream
())
def
_cleanup
(
self
):
if
self
.
_thread
and
self
.
_thread
.
is_alive
():
self
.
_thread
.
join
()
def
get
(
self
)
->
messages
.
ModelResponse
:
"""Build a ModelResponse from the data received from the stream so far."""
return
self
.
_ensure_stream_ready
()
.
get
()
def
usage
(
self
)
->
Usage
:
"""Get the usage of the response so far."""
return
self
.
_ensure_stream_ready
()
.
usage
()
@property
def
model_name
(
self
)
->
str
:
"""Get the model name of the response."""
return
self
.
_ensure_stream_ready
()
.
model_name
@property
def
timestamp
(
self
)
->
datetime
:
"""Get the timestamp of the response."""
return
self
.
_ensure_stream_ready
()
.
timestamp
__iter__
__iter__
()
->
Iterator
[
ModelResponseStreamEvent
]
Stream the response as an iterable of
ModelResponseStreamEvent
s.
Source code in
pydantic_ai_slim/pydantic_ai/direct.py
298
299
300
301
302
303
304
305
306
307
308
309
def
__iter__
(
self
)
->
Iterator
[
messages
.
ModelResponseStreamEvent
]:
"""Stream the response as an iterable of [`ModelResponseStreamEvent`][pydantic_ai.messages.ModelResponseStreamEvent]s."""
self
.
_check_context_manager_usage
()
while
True
:
item
=
self
.
_queue
.
get
()
if
item
is
None
:
# End of stream
break
elif
isinstance
(
item
,
Exception
):
raise
item
else
:
yield
item
get
get
()
->
ModelResponse
Build a ModelResponse from the data received from the stream so far.
Source code in
pydantic_ai_slim/pydantic_ai/direct.py
365
366
367
def
get
(
self
)
->
messages
.
ModelResponse
:
"""Build a ModelResponse from the data received from the stream so far."""
return
self
.
_ensure_stream_ready
()
.
get
()
usage
usage
()
->
Usage
Get the usage of the response so far.
Source code in
pydantic_ai_slim/pydantic_ai/direct.py
369
370
371
def
usage
(
self
)
->
Usage
:
"""Get the usage of the response so far."""
return
self
.
_ensure_stream_ready
()
.
usage
()
model_name
property
model_name
:
str
Get the model name of the response.
timestamp
property
timestamp
:
datetime
Get the timestamp of the response.