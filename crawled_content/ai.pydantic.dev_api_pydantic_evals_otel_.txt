PydanticAI
pydantic/pydantic-ai
Introduction
Installation
Getting Help
Contributing
Troubleshooting
Upgrade Guide
Documentation
Documentation
Agents
Models
Models
OpenAI
Anthropic
Gemini
Google
Bedrock
Cohere
Groq
Mistral
Dependencies
Function Tools
Common Tools
Output
Messages and chat history
Unit testing
Debugging and Monitoring
Multi-agent Applications
Graphs
Evals
Image, Audio, Video & Document Input
Thinking
Direct Model Requests
MCP
MCP
Client
Server
MCP Run Python
A2A
Command Line Interface (CLI)
Examples
Examples
Pydantic Model
Weather agent
Bank support
SQL Generation
Flight booking
RAG
Stream markdown
Stream whales
Chat App with FastAPI
Question Graph
Slack Lead Qualifier with Modal
API Reference
API Reference
pydantic_ai.agent
pydantic_ai.tools
pydantic_ai.common_tools
pydantic_ai.output
pydantic_ai.result
pydantic_ai.messages
pydantic_ai.exceptions
pydantic_ai.settings
pydantic_ai.usage
pydantic_ai.mcp
pydantic_ai.format_as_xml
pydantic_ai.format_prompt
pydantic_ai.direct
pydantic_ai.models
pydantic_ai.models.openai
pydantic_ai.models.anthropic
pydantic_ai.models.bedrock
pydantic_ai.models.cohere
pydantic_ai.models.gemini
pydantic_ai.models.google
pydantic_ai.models.groq
pydantic_ai.models.instrumented
pydantic_ai.models.mistral
pydantic_ai.models.test
pydantic_ai.models.function
pydantic_ai.models.fallback
pydantic_ai.models.wrapper
pydantic_ai.models.mcp_sampling
pydantic_ai.profiles
pydantic_ai.providers
pydantic_graph
pydantic_graph.nodes
pydantic_graph.persistence
pydantic_graph.mermaid
pydantic_graph.exceptions
pydantic_evals.dataset
pydantic_evals.evaluators
pydantic_evals.reporting
pydantic_evals.otel
pydantic_evals.otel
Table of contents
otel
SpanNode
duration
descendants
ancestors
add_child
find_children
first_child
any_child
find_descendants
first_descendant
any_descendant
find_ancestors
first_ancestor
any_ancestor
matches
repr_xml
SpanQuery
stop_recursing_when
SpanTree
add_spans
find
first
any
__iter__
repr_xml
pydantic_evals.generation
fasta2a
Table of contents
otel
SpanNode
duration
descendants
ancestors
add_child
find_children
first_child
any_child
find_descendants
first_descendant
any_descendant
find_ancestors
first_ancestor
any_ancestor
matches
repr_xml
SpanQuery
stop_recursing_when
SpanTree
add_spans
find
first
any
__iter__
repr_xml
pydantic_evals.otel
SpanNode
dataclass
A node in the span tree; provides references to parents/children for easy traversal and queries.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
@dataclass
(
repr
=
False
)
class
SpanNode
:
"""A node in the span tree; provides references to parents/children for easy traversal and queries."""
name
:
str
trace_id
:
int
span_id
:
int
parent_span_id
:
int
|
None
start_timestamp
:
datetime
end_timestamp
:
datetime
attributes
:
dict
[
str
,
AttributeValue
]
@property
def
duration
(
self
)
->
timedelta
:
"""Return the span's duration as a timedelta, or None if start/end not set."""
return
self
.
end_timestamp
-
self
.
start_timestamp
@property
def
children
(
self
)
->
list
[
SpanNode
]:
return
list
(
self
.
children_by_id
.
values
())
@property
def
descendants
(
self
)
->
list
[
SpanNode
]:
"""Return all descendants of this node in DFS order."""
return
self
.
find_descendants
(
lambda
_
:
True
)
@property
def
ancestors
(
self
)
->
list
[
SpanNode
]:
"""Return all ancestors of this node."""
return
self
.
find_ancestors
(
lambda
_
:
True
)
@property
def
node_key
(
self
)
->
str
:
return
f
'
{
self
.
trace_id
:
032x
}
:
{
self
.
span_id
:
016x
}
'
@property
def
parent_node_key
(
self
)
->
str
|
None
:
return
None
if
self
.
parent_span_id
is
None
else
f
'
{
self
.
trace_id
:
032x
}
:
{
self
.
parent_span_id
:
016x
}
'
# -------------------------------------------------------------------------
# Construction
# -------------------------------------------------------------------------
def
__post_init__
(
self
):
self
.
parent
:
SpanNode
|
None
=
None
self
.
children_by_id
:
dict
[
str
,
SpanNode
]
=
{}
@staticmethod
def
from_readable_span
(
span
:
ReadableSpan
)
->
SpanNode
:
assert
span
.
context
is
not
None
,
'Span has no context'
assert
span
.
start_time
is
not
None
,
'Span has no start time'
assert
span
.
end_time
is
not
None
,
'Span has no end time'
return
SpanNode
(
name
=
span
.
name
,
trace_id
=
span
.
context
.
trace_id
,
span_id
=
span
.
context
.
span_id
,
parent_span_id
=
span
.
parent
.
span_id
if
span
.
parent
else
None
,
start_timestamp
=
datetime
.
fromtimestamp
(
span
.
start_time
/
1e9
,
tz
=
timezone
.
utc
),
end_timestamp
=
datetime
.
fromtimestamp
(
span
.
end_time
/
1e9
,
tz
=
timezone
.
utc
),
attributes
=
dict
(
span
.
attributes
or
{}),
)
def
add_child
(
self
,
child
:
SpanNode
)
->
None
:
"""Attach a child node to this node's list of children."""
assert
child
.
trace_id
==
self
.
trace_id
,
f
"traces don't match:
{
child
.
trace_id
:
032x
}
!=
{
self
.
trace_id
:
032x
}
"
assert
child
.
parent_span_id
==
self
.
span_id
,
(
f
'parent span mismatch:
{
child
.
parent_span_id
:
016x
}
!=
{
self
.
span_id
:
016x
}
'
)
self
.
children_by_id
[
child
.
node_key
]
=
child
child
.
parent
=
self
# -------------------------------------------------------------------------
# Child queries
# -------------------------------------------------------------------------
def
find_children
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
list
[
SpanNode
]:
"""Return all immediate children that satisfy the given predicate."""
return
list
(
self
.
_filter_children
(
predicate
))
def
first_child
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
SpanNode
|
None
:
"""Return the first immediate child that satisfies the given predicate, or None if none match."""
return
next
(
self
.
_filter_children
(
predicate
),
None
)
def
any_child
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
bool
:
"""Returns True if there is at least one child that satisfies the predicate."""
return
self
.
first_child
(
predicate
)
is
not
None
def
_filter_children
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
Iterator
[
SpanNode
]:
return
(
child
for
child
in
self
.
children
if
child
.
matches
(
predicate
))
# -------------------------------------------------------------------------
# Descendant queries (DFS)
# -------------------------------------------------------------------------
def
find_descendants
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
list
[
SpanNode
]:
"""Return all descendant nodes that satisfy the given predicate in DFS order."""
return
list
(
self
.
_filter_descendants
(
predicate
,
stop_recursing_when
))
def
first_descendant
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
SpanNode
|
None
:
"""DFS: Return the first descendant (in DFS order) that satisfies the given predicate, or `None` if none match."""
return
next
(
self
.
_filter_descendants
(
predicate
,
stop_recursing_when
),
None
)
def
any_descendant
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
bool
:
"""Returns `True` if there is at least one descendant that satisfies the predicate."""
return
self
.
first_descendant
(
predicate
,
stop_recursing_when
)
is
not
None
def
_filter_descendants
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
)
->
Iterator
[
SpanNode
]:
stack
=
list
(
self
.
children
)
while
stack
:
node
=
stack
.
pop
()
if
node
.
matches
(
predicate
):
yield
node
if
stop_recursing_when
is
not
None
and
node
.
matches
(
stop_recursing_when
):
continue
stack
.
extend
(
node
.
children
)
# -------------------------------------------------------------------------
# Ancestor queries (DFS "up" the chain)
# -------------------------------------------------------------------------
def
find_ancestors
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
list
[
SpanNode
]:
"""Return all ancestors that satisfy the given predicate."""
return
list
(
self
.
_filter_ancestors
(
predicate
,
stop_recursing_when
))
def
first_ancestor
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
SpanNode
|
None
:
"""Return the closest ancestor that satisfies the given predicate, or `None` if none match."""
return
next
(
self
.
_filter_ancestors
(
predicate
,
stop_recursing_when
),
None
)
def
any_ancestor
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
bool
:
"""Returns True if any ancestor satisfies the predicate."""
return
self
.
first_ancestor
(
predicate
,
stop_recursing_when
)
is
not
None
def
_filter_ancestors
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
)
->
Iterator
[
SpanNode
]:
node
=
self
.
parent
while
node
:
if
node
.
matches
(
predicate
):
yield
node
if
stop_recursing_when
is
not
None
and
node
.
matches
(
stop_recursing_when
):
break
node
=
node
.
parent
# -------------------------------------------------------------------------
# Query matching
# -------------------------------------------------------------------------
def
matches
(
self
,
query
:
SpanQuery
|
SpanPredicate
)
->
bool
:
"""Check if the span node matches the query conditions or predicate."""
if
callable
(
query
):
return
query
(
self
)
return
self
.
_matches_query
(
query
)
def
_matches_query
(
self
,
query
:
SpanQuery
)
->
bool
:
# noqa C901
"""Check if the span matches the query conditions."""
# Logical combinations
if
or_
:=
query
.
get
(
'or_'
):
if
len
(
query
)
>
1
:
raise
ValueError
(
"Cannot combine 'or_' conditions with other conditions at the same level"
)
return
any
(
self
.
_matches_query
(
q
)
for
q
in
or_
)
if
not_
:=
query
.
get
(
'not_'
):
if
self
.
_matches_query
(
not_
):
return
False
if
and_
:=
query
.
get
(
'and_'
):
results
=
[
self
.
_matches_query
(
q
)
for
q
in
and_
]
if
not
all
(
results
):
return
False
# At this point, all existing ANDs and no existing ORs have passed, so it comes down to this condition
# Name conditions
if
(
name_equals
:=
query
.
get
(
'name_equals'
))
and
self
.
name
!=
name_equals
:
return
False
if
(
name_contains
:=
query
.
get
(
'name_contains'
))
and
name_contains
not
in
self
.
name
:
return
False
if
(
name_matches_regex
:=
query
.
get
(
'name_matches_regex'
))
and
not
re
.
match
(
name_matches_regex
,
self
.
name
):
return
False
# Attribute conditions
if
(
has_attributes
:=
query
.
get
(
'has_attributes'
))
and
not
all
(
self
.
attributes
.
get
(
key
)
==
value
for
key
,
value
in
has_attributes
.
items
()
):
return
False
if
(
has_attributes_keys
:=
query
.
get
(
'has_attribute_keys'
))
and
not
all
(
key
in
self
.
attributes
for
key
in
has_attributes_keys
):
return
False
# Timing conditions
if
(
min_duration
:=
query
.
get
(
'min_duration'
))
is
not
None
:
if
not
isinstance
(
min_duration
,
timedelta
):
min_duration
=
timedelta
(
seconds
=
min_duration
)
if
self
.
duration
<
min_duration
:
return
False
if
(
max_duration
:=
query
.
get
(
'max_duration'
))
is
not
None
:
if
not
isinstance
(
max_duration
,
timedelta
):
max_duration
=
timedelta
(
seconds
=
max_duration
)
if
self
.
duration
>
max_duration
:
return
False
# Children conditions
if
(
min_child_count
:=
query
.
get
(
'min_child_count'
))
and
len
(
self
.
children
)
<
min_child_count
:
return
False
if
(
max_child_count
:=
query
.
get
(
'max_child_count'
))
and
len
(
self
.
children
)
>
max_child_count
:
return
False
if
(
some_child_has
:=
query
.
get
(
'some_child_has'
))
and
not
any
(
child
.
_matches_query
(
some_child_has
)
for
child
in
self
.
children
):
return
False
if
(
all_children_have
:=
query
.
get
(
'all_children_have'
))
and
not
all
(
child
.
_matches_query
(
all_children_have
)
for
child
in
self
.
children
):
return
False
if
(
no_child_has
:=
query
.
get
(
'no_child_has'
))
and
any
(
child
.
_matches_query
(
no_child_has
)
for
child
in
self
.
children
):
return
False
# Descendant conditions
# The following local functions with cache decorators are used to avoid repeatedly evaluating these properties
@cache
def
descendants
():
return
self
.
descendants
@cache
def
pruned_descendants
():
stop_recursing_when
=
query
.
get
(
'stop_recursing_when'
)
return
(
self
.
_filter_descendants
(
lambda
_
:
True
,
stop_recursing_when
)
if
stop_recursing_when
else
descendants
()
)
if
(
min_descendant_count
:=
query
.
get
(
'min_descendant_count'
))
and
len
(
descendants
())
<
min_descendant_count
:
return
False
if
(
max_descendant_count
:=
query
.
get
(
'max_descendant_count'
))
and
len
(
descendants
())
>
max_descendant_count
:
return
False
if
(
some_descendant_has
:=
query
.
get
(
'some_descendant_has'
))
and
not
any
(
descendant
.
_matches_query
(
some_descendant_has
)
for
descendant
in
pruned_descendants
()
):
return
False
if
(
all_descendants_have
:=
query
.
get
(
'all_descendants_have'
))
and
not
all
(
descendant
.
_matches_query
(
all_descendants_have
)
for
descendant
in
pruned_descendants
()
):
return
False
if
(
no_descendant_has
:=
query
.
get
(
'no_descendant_has'
))
and
any
(
descendant
.
_matches_query
(
no_descendant_has
)
for
descendant
in
pruned_descendants
()
):
return
False
# Ancestor conditions
# The following local functions with cache decorators are used to avoid repeatedly evaluating these properties
@cache
def
ancestors
():
return
self
.
ancestors
@cache
def
pruned_ancestors
():
stop_recursing_when
=
query
.
get
(
'stop_recursing_when'
)
return
self
.
_filter_ancestors
(
lambda
_
:
True
,
stop_recursing_when
)
if
stop_recursing_when
else
ancestors
()
if
(
min_depth
:=
query
.
get
(
'min_depth'
))
and
len
(
ancestors
())
<
min_depth
:
return
False
if
(
max_depth
:=
query
.
get
(
'max_depth'
))
and
len
(
ancestors
())
>
max_depth
:
return
False
if
(
some_ancestor_has
:=
query
.
get
(
'some_ancestor_has'
))
and
not
any
(
ancestor
.
_matches_query
(
some_ancestor_has
)
for
ancestor
in
pruned_ancestors
()
):
return
False
if
(
all_ancestors_have
:=
query
.
get
(
'all_ancestors_have'
))
and
not
all
(
ancestor
.
_matches_query
(
all_ancestors_have
)
for
ancestor
in
pruned_ancestors
()
):
return
False
if
(
no_ancestor_has
:=
query
.
get
(
'no_ancestor_has'
))
and
any
(
ancestor
.
_matches_query
(
no_ancestor_has
)
for
ancestor
in
pruned_ancestors
()
):
return
False
return
True
# -------------------------------------------------------------------------
# String representation
# -------------------------------------------------------------------------
def
repr_xml
(
self
,
include_children
:
bool
=
True
,
include_trace_id
:
bool
=
False
,
include_span_id
:
bool
=
False
,
include_start_timestamp
:
bool
=
False
,
include_duration
:
bool
=
False
,
)
->
str
:
"""Return an XML-like string representation of the node.
Optionally includes children, trace_id, span_id, start_timestamp, and duration.
"""
first_line_parts
=
[
f
'<SpanNode name=
{
self
.
name
!r}
'
]
if
include_trace_id
:
first_line_parts
.
append
(
f
"trace_id='
{
self
.
trace_id
:
032x
}
'"
)
if
include_span_id
:
first_line_parts
.
append
(
f
"span_id='
{
self
.
span_id
:
016x
}
'"
)
if
include_start_timestamp
:
first_line_parts
.
append
(
f
'start_timestamp=
{
self
.
start_timestamp
.
isoformat
()
!r}
'
)
if
include_duration
:
first_line_parts
.
append
(
f
"duration='
{
self
.
duration
}
'"
)
extra_lines
:
list
[
str
]
=
[]
if
include_children
and
self
.
children
:
first_line_parts
.
append
(
'>'
)
for
child
in
self
.
children
:
extra_lines
.
append
(
indent
(
child
.
repr_xml
(
include_children
=
include_children
,
include_trace_id
=
include_trace_id
,
include_span_id
=
include_span_id
,
include_start_timestamp
=
include_start_timestamp
,
include_duration
=
include_duration
,
),
'  '
,
)
)
extra_lines
.
append
(
'</SpanNode>'
)
else
:
if
self
.
children
:
first_line_parts
.
append
(
'children=...'
)
first_line_parts
.
append
(
'/>'
)
return
'
\n
'
.
join
([
' '
.
join
(
first_line_parts
),
*
extra_lines
])
def
__str__
(
self
)
->
str
:
if
self
.
children
:
return
f
"<SpanNode name=
{
self
.
name
!r}
span_id='
{
self
.
span_id
:
016x
}
'>...</SpanNode>"
else
:
return
f
"<SpanNode name=
{
self
.
name
!r}
span_id='
{
self
.
span_id
:
016x
}
' />"
def
__repr__
(
self
)
->
str
:
return
self
.
repr_xml
()
duration
property
duration
:
timedelta
Return the span's duration as a timedelta, or None if start/end not set.
descendants
property
descendants
:
list
[
SpanNode
]
Return all descendants of this node in DFS order.
ancestors
property
ancestors
:
list
[
SpanNode
]
Return all ancestors of this node.
add_child
add_child
(
child
:
SpanNode
)
->
None
Attach a child node to this node's list of children.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
151
152
153
154
155
156
157
158
def
add_child
(
self
,
child
:
SpanNode
)
->
None
:
"""Attach a child node to this node's list of children."""
assert
child
.
trace_id
==
self
.
trace_id
,
f
"traces don't match:
{
child
.
trace_id
:
032x
}
!=
{
self
.
trace_id
:
032x
}
"
assert
child
.
parent_span_id
==
self
.
span_id
,
(
f
'parent span mismatch:
{
child
.
parent_span_id
:
016x
}
!=
{
self
.
span_id
:
016x
}
'
)
self
.
children_by_id
[
child
.
node_key
]
=
child
child
.
parent
=
self
find_children
find_children
(
predicate
:
SpanQuery
|
SpanPredicate
,
)
->
list
[
SpanNode
]
Return all immediate children that satisfy the given predicate.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
163
164
165
def
find_children
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
list
[
SpanNode
]:
"""Return all immediate children that satisfy the given predicate."""
return
list
(
self
.
_filter_children
(
predicate
))
first_child
first_child
(
predicate
:
SpanQuery
|
SpanPredicate
,
)
->
SpanNode
|
None
Return the first immediate child that satisfies the given predicate, or None if none match.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
167
168
169
def
first_child
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
SpanNode
|
None
:
"""Return the first immediate child that satisfies the given predicate, or None if none match."""
return
next
(
self
.
_filter_children
(
predicate
),
None
)
any_child
any_child
(
predicate
:
SpanQuery
|
SpanPredicate
)
->
bool
Returns True if there is at least one child that satisfies the predicate.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
171
172
173
def
any_child
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
bool
:
"""Returns True if there is at least one child that satisfies the predicate."""
return
self
.
first_child
(
predicate
)
is
not
None
find_descendants
find_descendants
(
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
(
SpanQuery
|
SpanPredicate
|
None
)
=
None
,
)
->
list
[
SpanNode
]
Return all descendant nodes that satisfy the given predicate in DFS order.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
181
182
183
184
185
def
find_descendants
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
list
[
SpanNode
]:
"""Return all descendant nodes that satisfy the given predicate in DFS order."""
return
list
(
self
.
_filter_descendants
(
predicate
,
stop_recursing_when
))
first_descendant
first_descendant
(
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
(
SpanQuery
|
SpanPredicate
|
None
)
=
None
,
)
->
SpanNode
|
None
DFS: Return the first descendant (in DFS order) that satisfies the given predicate, or
None
if none match.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
187
188
189
190
191
def
first_descendant
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
SpanNode
|
None
:
"""DFS: Return the first descendant (in DFS order) that satisfies the given predicate, or `None` if none match."""
return
next
(
self
.
_filter_descendants
(
predicate
,
stop_recursing_when
),
None
)
any_descendant
any_descendant
(
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
(
SpanQuery
|
SpanPredicate
|
None
)
=
None
,
)
->
bool
Returns
True
if there is at least one descendant that satisfies the predicate.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
193
194
195
196
197
def
any_descendant
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
bool
:
"""Returns `True` if there is at least one descendant that satisfies the predicate."""
return
self
.
first_descendant
(
predicate
,
stop_recursing_when
)
is
not
None
find_ancestors
find_ancestors
(
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
(
SpanQuery
|
SpanPredicate
|
None
)
=
None
,
)
->
list
[
SpanNode
]
Return all ancestors that satisfy the given predicate.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
214
215
216
217
218
def
find_ancestors
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
list
[
SpanNode
]:
"""Return all ancestors that satisfy the given predicate."""
return
list
(
self
.
_filter_ancestors
(
predicate
,
stop_recursing_when
))
first_ancestor
first_ancestor
(
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
(
SpanQuery
|
SpanPredicate
|
None
)
=
None
,
)
->
SpanNode
|
None
Return the closest ancestor that satisfies the given predicate, or
None
if none match.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
220
221
222
223
224
def
first_ancestor
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
SpanNode
|
None
:
"""Return the closest ancestor that satisfies the given predicate, or `None` if none match."""
return
next
(
self
.
_filter_ancestors
(
predicate
,
stop_recursing_when
),
None
)
any_ancestor
any_ancestor
(
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
(
SpanQuery
|
SpanPredicate
|
None
)
=
None
,
)
->
bool
Returns True if any ancestor satisfies the predicate.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
226
227
228
229
230
def
any_ancestor
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
,
stop_recursing_when
:
SpanQuery
|
SpanPredicate
|
None
=
None
)
->
bool
:
"""Returns True if any ancestor satisfies the predicate."""
return
self
.
first_ancestor
(
predicate
,
stop_recursing_when
)
is
not
None
matches
matches
(
query
:
SpanQuery
|
SpanPredicate
)
->
bool
Check if the span node matches the query conditions or predicate.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
246
247
248
249
250
251
def
matches
(
self
,
query
:
SpanQuery
|
SpanPredicate
)
->
bool
:
"""Check if the span node matches the query conditions or predicate."""
if
callable
(
query
):
return
query
(
self
)
return
self
.
_matches_query
(
query
)
repr_xml
repr_xml
(
include_children
:
bool
=
True
,
include_trace_id
:
bool
=
False
,
include_span_id
:
bool
=
False
,
include_start_timestamp
:
bool
=
False
,
include_duration
:
bool
=
False
,
)
->
str
Return an XML-like string representation of the node.
Optionally includes children, trace_id, span_id, start_timestamp, and duration.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
def
repr_xml
(
self
,
include_children
:
bool
=
True
,
include_trace_id
:
bool
=
False
,
include_span_id
:
bool
=
False
,
include_start_timestamp
:
bool
=
False
,
include_duration
:
bool
=
False
,
)
->
str
:
"""Return an XML-like string representation of the node.
Optionally includes children, trace_id, span_id, start_timestamp, and duration.
"""
first_line_parts
=
[
f
'<SpanNode name=
{
self
.
name
!r}
'
]
if
include_trace_id
:
first_line_parts
.
append
(
f
"trace_id='
{
self
.
trace_id
:
032x
}
'"
)
if
include_span_id
:
first_line_parts
.
append
(
f
"span_id='
{
self
.
span_id
:
016x
}
'"
)
if
include_start_timestamp
:
first_line_parts
.
append
(
f
'start_timestamp=
{
self
.
start_timestamp
.
isoformat
()
!r}
'
)
if
include_duration
:
first_line_parts
.
append
(
f
"duration='
{
self
.
duration
}
'"
)
extra_lines
:
list
[
str
]
=
[]
if
include_children
and
self
.
children
:
first_line_parts
.
append
(
'>'
)
for
child
in
self
.
children
:
extra_lines
.
append
(
indent
(
child
.
repr_xml
(
include_children
=
include_children
,
include_trace_id
=
include_trace_id
,
include_span_id
=
include_span_id
,
include_start_timestamp
=
include_start_timestamp
,
include_duration
=
include_duration
,
),
'  '
,
)
)
extra_lines
.
append
(
'</SpanNode>'
)
else
:
if
self
.
children
:
first_line_parts
.
append
(
'children=...'
)
first_line_parts
.
append
(
'/>'
)
return
'
\n
'
.
join
([
' '
.
join
(
first_line_parts
),
*
extra_lines
])
SpanQuery
Bases:
TypedDict
A serializable query for filtering SpanNodes based on various conditions.
All fields are optional and combined with AND logic by default.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
class
SpanQuery
(
TypedDict
,
total
=
False
):
"""A serializable query for filtering SpanNodes based on various conditions.
All fields are optional and combined with AND logic by default.
"""
# These fields are ordered to match the implementation of SpanNode.matches_query for easy review.
# * Individual span conditions come first because these are generally the cheapest to evaluate
# * Logical combinations come next because they may just be combinations of individual span conditions
# * Related-span conditions come last because they may require the most work to evaluate
# Individual span conditions
## Name conditions
name_equals
:
str
name_contains
:
str
name_matches_regex
:
str
# regex pattern
## Attribute conditions
has_attributes
:
dict
[
str
,
Any
]
has_attribute_keys
:
list
[
str
]
## Timing conditions
min_duration
:
timedelta
|
float
max_duration
:
timedelta
|
float
# Logical combinations of conditions
not_
:
SpanQuery
and_
:
list
[
SpanQuery
]
or_
:
list
[
SpanQuery
]
# Child conditions
min_child_count
:
int
max_child_count
:
int
some_child_has
:
SpanQuery
all_children_have
:
SpanQuery
no_child_has
:
SpanQuery
# Recursive conditions
stop_recursing_when
:
SpanQuery
"""If present, stop recursing through ancestors or descendants at nodes that match this condition."""
## Descendant conditions
min_descendant_count
:
int
max_descendant_count
:
int
some_descendant_has
:
SpanQuery
all_descendants_have
:
SpanQuery
no_descendant_has
:
SpanQuery
## Ancestor conditions
min_depth
:
int
# depth is equivalent to ancestor count; roots have depth 0
max_depth
:
int
some_ancestor_has
:
SpanQuery
all_ancestors_have
:
SpanQuery
no_ancestor_has
:
SpanQuery
stop_recursing_when
instance-attribute
stop_recursing_when
:
SpanQuery
If present, stop recursing through ancestors or descendants at nodes that match this condition.
SpanTree
dataclass
A container that builds a hierarchy of SpanNode objects from a list of finished spans.
You can then search or iterate the tree to make your assertions (using DFS for traversal).
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
@dataclass
(
repr
=
False
)
class
SpanTree
:
"""A container that builds a hierarchy of SpanNode objects from a list of finished spans.
You can then search or iterate the tree to make your assertions (using DFS for traversal).
"""
roots
:
list
[
SpanNode
]
=
field
(
default_factory
=
list
)
nodes_by_id
:
dict
[
str
,
SpanNode
]
=
field
(
default_factory
=
dict
)
# -------------------------------------------------------------------------
# Construction
# -------------------------------------------------------------------------
def
__post_init__
(
self
):
self
.
_rebuild_tree
()
def
add_spans
(
self
,
spans
:
list
[
SpanNode
])
->
None
:
"""Add a list of spans to the tree, rebuilding the tree structure."""
for
span
in
spans
:
self
.
nodes_by_id
[
span
.
node_key
]
=
span
self
.
_rebuild_tree
()
def
add_readable_spans
(
self
,
readable_spans
:
list
[
ReadableSpan
]):
self
.
add_spans
([
SpanNode
.
from_readable_span
(
span
)
for
span
in
readable_spans
])
def
_rebuild_tree
(
self
):
# Ensure spans are ordered by start_timestamp so that roots and children end up in the right order
nodes
=
list
(
self
.
nodes_by_id
.
values
())
nodes
.
sort
(
key
=
lambda
node
:
node
.
start_timestamp
or
datetime
.
min
)
self
.
nodes_by_id
=
{
node
.
node_key
:
node
for
node
in
nodes
}
# Build the parent/child relationships
for
node
in
self
.
nodes_by_id
.
values
():
parent_node_key
=
node
.
parent_node_key
if
parent_node_key
is
not
None
:
parent_node
=
self
.
nodes_by_id
.
get
(
parent_node_key
)
if
parent_node
is
not
None
:
parent_node
.
add_child
(
node
)
# Determine the roots
# A node is a "root" if its parent is None or if its parent's span_id is not in the current set of spans.
self
.
roots
=
[]
for
node
in
self
.
nodes_by_id
.
values
():
parent_node_key
=
node
.
parent_node_key
if
parent_node_key
is
None
or
parent_node_key
not
in
self
.
nodes_by_id
:
self
.
roots
.
append
(
node
)
# -------------------------------------------------------------------------
# Node filtering and iteration
# -------------------------------------------------------------------------
def
find
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
list
[
SpanNode
]:
"""Find all nodes in the entire tree that match the predicate, scanning from each root in DFS order."""
return
list
(
self
.
_filter
(
predicate
))
def
first
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
SpanNode
|
None
:
"""Find the first node that matches a predicate, scanning from each root in DFS order. Returns `None` if not found."""
return
next
(
self
.
_filter
(
predicate
),
None
)
def
any
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
bool
:
"""Returns True if any node in the tree matches the predicate."""
return
self
.
first
(
predicate
)
is
not
None
def
_filter
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
Iterator
[
SpanNode
]:
for
node
in
self
:
if
node
.
matches
(
predicate
):
yield
node
def
__iter__
(
self
)
->
Iterator
[
SpanNode
]:
"""Return an iterator over all nodes in the tree."""
return
iter
(
self
.
nodes_by_id
.
values
())
# -------------------------------------------------------------------------
# String representation
# -------------------------------------------------------------------------
def
repr_xml
(
self
,
include_children
:
bool
=
True
,
include_trace_id
:
bool
=
False
,
include_span_id
:
bool
=
False
,
include_start_timestamp
:
bool
=
False
,
include_duration
:
bool
=
False
,
)
->
str
:
"""Return an XML-like string representation of the tree, optionally including children, trace_id, span_id, duration, and timestamps."""
if
not
self
.
roots
:
return
'<SpanTree />'
repr_parts
=
[
'<SpanTree>'
,
*
[
indent
(
root
.
repr_xml
(
include_children
=
include_children
,
include_trace_id
=
include_trace_id
,
include_span_id
=
include_span_id
,
include_start_timestamp
=
include_start_timestamp
,
include_duration
=
include_duration
,
),
'  '
,
)
for
root
in
self
.
roots
],
'</SpanTree>'
,
]
return
'
\n
'
.
join
(
repr_parts
)
def
__str__
(
self
):
return
f
'<SpanTree num_roots=
{
len
(
self
.
roots
)
}
total_spans=
{
len
(
self
.
nodes_by_id
)
}
/>'
def
__repr__
(
self
):
return
self
.
repr_xml
()
add_spans
add_spans
(
spans
:
list
[
SpanNode
])
->
None
Add a list of spans to the tree, rebuilding the tree structure.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
454
455
456
457
458
def
add_spans
(
self
,
spans
:
list
[
SpanNode
])
->
None
:
"""Add a list of spans to the tree, rebuilding the tree structure."""
for
span
in
spans
:
self
.
nodes_by_id
[
span
.
node_key
]
=
span
self
.
_rebuild_tree
()
find
find
(
predicate
:
SpanQuery
|
SpanPredicate
,
)
->
list
[
SpanNode
]
Find all nodes in the entire tree that match the predicate, scanning from each root in DFS order.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
488
489
490
def
find
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
list
[
SpanNode
]:
"""Find all nodes in the entire tree that match the predicate, scanning from each root in DFS order."""
return
list
(
self
.
_filter
(
predicate
))
first
first
(
predicate
:
SpanQuery
|
SpanPredicate
,
)
->
SpanNode
|
None
Find the first node that matches a predicate, scanning from each root in DFS order. Returns
None
if not found.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
492
493
494
def
first
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
SpanNode
|
None
:
"""Find the first node that matches a predicate, scanning from each root in DFS order. Returns `None` if not found."""
return
next
(
self
.
_filter
(
predicate
),
None
)
any
any
(
predicate
:
SpanQuery
|
SpanPredicate
)
->
bool
Returns True if any node in the tree matches the predicate.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
496
497
498
def
any
(
self
,
predicate
:
SpanQuery
|
SpanPredicate
)
->
bool
:
"""Returns True if any node in the tree matches the predicate."""
return
self
.
first
(
predicate
)
is
not
None
__iter__
__iter__
()
->
Iterator
[
SpanNode
]
Return an iterator over all nodes in the tree.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
505
506
507
def
__iter__
(
self
)
->
Iterator
[
SpanNode
]:
"""Return an iterator over all nodes in the tree."""
return
iter
(
self
.
nodes_by_id
.
values
())
repr_xml
repr_xml
(
include_children
:
bool
=
True
,
include_trace_id
:
bool
=
False
,
include_span_id
:
bool
=
False
,
include_start_timestamp
:
bool
=
False
,
include_duration
:
bool
=
False
,
)
->
str
Return an XML-like string representation of the tree, optionally including children, trace_id, span_id, duration, and timestamps.
Source code in
pydantic_evals/pydantic_evals/otel/span_tree.py
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
def
repr_xml
(
self
,
include_children
:
bool
=
True
,
include_trace_id
:
bool
=
False
,
include_span_id
:
bool
=
False
,
include_start_timestamp
:
bool
=
False
,
include_duration
:
bool
=
False
,
)
->
str
:
"""Return an XML-like string representation of the tree, optionally including children, trace_id, span_id, duration, and timestamps."""
if
not
self
.
roots
:
return
'<SpanTree />'
repr_parts
=
[
'<SpanTree>'
,
*
[
indent
(
root
.
repr_xml
(
include_children
=
include_children
,
include_trace_id
=
include_trace_id
,
include_span_id
=
include_span_id
,
include_start_timestamp
=
include_start_timestamp
,
include_duration
=
include_duration
,
),
'  '
,
)
for
root
in
self
.
roots
],
'</SpanTree>'
,
]
return
'
\n
'
.
join
(
repr_parts
)