PydanticAI
pydantic/pydantic-ai
Introduction
Installation
Getting Help
Contributing
Troubleshooting
Upgrade Guide
Documentation
Documentation
Agents
Models
Models
OpenAI
Anthropic
Gemini
Google
Bedrock
Cohere
Groq
Mistral
Dependencies
Function Tools
Common Tools
Output
Messages and chat history
Unit testing
Debugging and Monitoring
Multi-agent Applications
Graphs
Evals
Image, Audio, Video & Document Input
Thinking
Direct Model Requests
MCP
MCP
Client
Server
MCP Run Python
A2A
Command Line Interface (CLI)
Examples
Examples
Pydantic Model
Weather agent
Bank support
SQL Generation
Flight booking
RAG
Stream markdown
Stream whales
Chat App with FastAPI
Question Graph
Slack Lead Qualifier with Modal
API Reference
API Reference
pydantic_ai.agent
pydantic_ai.tools
pydantic_ai.common_tools
pydantic_ai.output
pydantic_ai.result
pydantic_ai.messages
pydantic_ai.exceptions
pydantic_ai.settings
pydantic_ai.usage
pydantic_ai.mcp
pydantic_ai.format_as_xml
pydantic_ai.format_prompt
pydantic_ai.direct
pydantic_ai.models
pydantic_ai.models.openai
pydantic_ai.models.anthropic
pydantic_ai.models.bedrock
pydantic_ai.models.cohere
pydantic_ai.models.gemini
pydantic_ai.models.google
pydantic_ai.models.groq
pydantic_ai.models.instrumented
pydantic_ai.models.mistral
pydantic_ai.models.test
pydantic_ai.models.function
pydantic_ai.models.fallback
pydantic_ai.models.wrapper
pydantic_ai.models.mcp_sampling
pydantic_ai.profiles
pydantic_ai.profiles
Table of contents
ModelProfile
supports_tools
supports_json_schema_output
supports_json_object_output
default_structured_output_mode
prompted_output_template
json_schema_transformer
from_profile
update
openai
OpenAIModelProfile
openai_supports_strict_tool_definition
openai_supports_sampling_settings
openai_model_profile
OpenAIJsonSchemaTransformer
anthropic
anthropic_model_profile
google
google_model_profile
GoogleJsonSchemaTransformer
meta
meta_model_profile
amazon
amazon_model_profile
deepseek
deepseek_model_profile
grok
grok_model_profile
mistral
mistral_model_profile
qwen
qwen_model_profile
pydantic_ai.providers
pydantic_graph
pydantic_graph.nodes
pydantic_graph.persistence
pydantic_graph.mermaid
pydantic_graph.exceptions
pydantic_evals.dataset
pydantic_evals.evaluators
pydantic_evals.reporting
pydantic_evals.otel
pydantic_evals.generation
fasta2a
Table of contents
ModelProfile
supports_tools
supports_json_schema_output
supports_json_object_output
default_structured_output_mode
prompted_output_template
json_schema_transformer
from_profile
update
openai
OpenAIModelProfile
openai_supports_strict_tool_definition
openai_supports_sampling_settings
openai_model_profile
OpenAIJsonSchemaTransformer
anthropic
anthropic_model_profile
google
google_model_profile
GoogleJsonSchemaTransformer
meta
meta_model_profile
amazon
amazon_model_profile
deepseek
deepseek_model_profile
grok
grok_model_profile
mistral
mistral_model_profile
qwen
qwen_model_profile
pydantic_ai.profiles
Describes how requests to a specific model or family of models need to be constructed to get the best results, independent of the model and provider classes used.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/__init__.py
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
@dataclass
class
ModelProfile
:
"""Describes how requests to a specific model or family of models need to be constructed to get the best results, independent of the model and provider classes used."""
supports_tools
:
bool
=
True
"""Whether the model supports tools."""
supports_json_schema_output
:
bool
=
False
"""Whether the model supports JSON schema output."""
supports_json_object_output
:
bool
=
False
"""Whether the model supports JSON object output."""
default_structured_output_mode
:
StructuredOutputMode
=
'tool'
"""The default structured output mode to use for the model."""
prompted_output_template
:
str
=
dedent
(
"""
Always respond with a JSON object that's compatible with this schema:
{schema}
Don't include any text or Markdown fencing before or after.
"""
)
"""The instructions template to use for prompted structured output. The '{schema}' placeholder will be replaced with the JSON schema for the output."""
json_schema_transformer
:
type
[
JsonSchemaTransformer
]
|
None
=
None
"""The transformer to use to make JSON schemas for tools and structured output compatible with the model."""
@classmethod
def
from_profile
(
cls
,
profile
:
ModelProfile
|
None
)
->
Self
:
"""Build a ModelProfile subclass instance from a ModelProfile instance."""
if
isinstance
(
profile
,
cls
):
return
profile
return
cls
()
.
update
(
profile
)
def
update
(
self
,
profile
:
ModelProfile
|
None
)
->
Self
:
"""Update this ModelProfile (subclass) instance with the non-default values from another ModelProfile instance."""
if
not
profile
:
return
self
field_names
=
set
(
f
.
name
for
f
in
fields
(
self
))
non_default_attrs
=
{
f
.
name
:
getattr
(
profile
,
f
.
name
)
for
f
in
fields
(
profile
)
if
f
.
name
in
field_names
and
getattr
(
profile
,
f
.
name
)
!=
f
.
default
}
return
replace
(
self
,
**
non_default_attrs
)
supports_tools
class-attribute
instance-attribute
supports_tools
:
bool
=
True
Whether the model supports tools.
supports_json_schema_output
class-attribute
instance-attribute
supports_json_schema_output
:
bool
=
False
Whether the model supports JSON schema output.
supports_json_object_output
class-attribute
instance-attribute
supports_json_object_output
:
bool
=
False
Whether the model supports JSON object output.
default_structured_output_mode
class-attribute
instance-attribute
default_structured_output_mode
:
StructuredOutputMode
=
(
"tool"
)
The default structured output mode to use for the model.
prompted_output_template
class-attribute
instance-attribute
prompted_output_template
:
str
=
dedent
(
"
\n
Always respond with a JSON object that's compatible with this schema:
\n\n
{schema}
\n\n
Don't include any text or Markdown fencing before or after.
\n
"
)
The instructions template to use for prompted structured output. The '{schema}' placeholder will be replaced with the JSON schema for the output.
json_schema_transformer
class-attribute
instance-attribute
json_schema_transformer
:
(
type
[
JsonSchemaTransformer
]
|
None
)
=
None
The transformer to use to make JSON schemas for tools and structured output compatible with the model.
from_profile
classmethod
from_profile
(
profile
:
ModelProfile
|
None
)
->
Self
Build a ModelProfile subclass instance from a ModelProfile instance.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/__init__.py
38
39
40
41
42
43
@classmethod
def
from_profile
(
cls
,
profile
:
ModelProfile
|
None
)
->
Self
:
"""Build a ModelProfile subclass instance from a ModelProfile instance."""
if
isinstance
(
profile
,
cls
):
return
profile
return
cls
()
.
update
(
profile
)
update
update
(
profile
:
ModelProfile
|
None
)
->
Self
Update this ModelProfile (subclass) instance with the non-default values from another ModelProfile instance.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/__init__.py
45
46
47
48
49
50
51
52
53
54
55
def
update
(
self
,
profile
:
ModelProfile
|
None
)
->
Self
:
"""Update this ModelProfile (subclass) instance with the non-default values from another ModelProfile instance."""
if
not
profile
:
return
self
field_names
=
set
(
f
.
name
for
f
in
fields
(
self
))
non_default_attrs
=
{
f
.
name
:
getattr
(
profile
,
f
.
name
)
for
f
in
fields
(
profile
)
if
f
.
name
in
field_names
and
getattr
(
profile
,
f
.
name
)
!=
f
.
default
}
return
replace
(
self
,
**
non_default_attrs
)
OpenAIModelProfile
dataclass
Bases:
ModelProfile
Profile for models used with OpenAIModel.
ALL FIELDS MUST BE
openai_
PREFIXED SO YOU CAN MERGE THEM WITH OTHER MODELS.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/openai.py
11
12
13
14
15
16
17
18
19
20
21
22
@dataclass
class
OpenAIModelProfile
(
ModelProfile
):
"""Profile for models used with OpenAIModel.
ALL FIELDS MUST BE `openai_` PREFIXED SO YOU CAN MERGE THEM WITH OTHER MODELS.
"""
openai_supports_strict_tool_definition
:
bool
=
True
"""This can be set by a provider or user if the OpenAI-"compatible" API doesn't support strict tool definitions."""
openai_supports_sampling_settings
:
bool
=
True
"""Turn off to don't send sampling settings like `temperature` and `top_p` to models that don't support them, like OpenAI's o-series reasoning models."""
openai_supports_strict_tool_definition
class-attribute
instance-attribute
openai_supports_strict_tool_definition
:
bool
=
True
This can be set by a provider or user if the OpenAI-"compatible" API doesn't support strict tool definitions.
openai_supports_sampling_settings
class-attribute
instance-attribute
openai_supports_sampling_settings
:
bool
=
True
Turn off to don't send sampling settings like
temperature
and
top_p
to models that don't support them, like OpenAI's o-series reasoning models.
openai_model_profile
openai_model_profile
(
model_name
:
str
)
->
ModelProfile
Get the model profile for an OpenAI model.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/openai.py
25
26
27
28
29
30
31
32
33
34
35
36
def
openai_model_profile
(
model_name
:
str
)
->
ModelProfile
:
"""Get the model profile for an OpenAI model."""
is_reasoning_model
=
model_name
.
startswith
(
'o'
)
# Structured Outputs (output mode 'native') is only supported with the gpt-4o-mini, gpt-4o-mini-2024-07-18, and gpt-4o-2024-08-06 model snapshots and later.
# We leave it in here for all models because the `default_structured_output_mode` is `'tool'`, so `native` is only used
# when the user specifically uses the `NativeOutput` marker, so an error from the API is acceptable.
return
OpenAIModelProfile
(
json_schema_transformer
=
OpenAIJsonSchemaTransformer
,
supports_json_schema_output
=
True
,
supports_json_object_output
=
True
,
openai_supports_sampling_settings
=
not
is_reasoning_model
,
)
OpenAIJsonSchemaTransformer
dataclass
Bases:
JsonSchemaTransformer
Recursively handle the schema to make it compatible with OpenAI strict mode.
See https://platform.openai.com/docs/guides/function-calling?api-mode=responses#strict-mode for more details,
but this basically just requires:
*
additionalProperties
must be set to false for each object in the parameters
* all fields in properties must be marked as required
Source code in
pydantic_ai_slim/pydantic_ai/profiles/openai.py
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
@dataclass
class
OpenAIJsonSchemaTransformer
(
JsonSchemaTransformer
):
"""Recursively handle the schema to make it compatible with OpenAI strict mode.
See https://platform.openai.com/docs/guides/function-calling?api-mode=responses#strict-mode for more details,
but this basically just requires:
* `additionalProperties` must be set to false for each object in the parameters
* all fields in properties must be marked as required
"""
def
__init__
(
self
,
schema
:
JsonSchema
,
*
,
strict
:
bool
|
None
=
None
):
super
()
.
__init__
(
schema
,
strict
=
strict
)
self
.
root_ref
=
schema
.
get
(
'$ref'
)
def
walk
(
self
)
->
JsonSchema
:
# Note: OpenAI does not support anyOf at the root in strict mode
# However, we don't need to check for it here because we ensure in pydantic_ai._utils.check_object_json_schema
# that the root schema either has type 'object' or is recursive.
result
=
super
()
.
walk
()
# For recursive models, we need to tweak the schema to make it compatible with strict mode.
# Because the following should never change the semantics of the schema we apply it unconditionally.
if
self
.
root_ref
is
not
None
:
result
.
pop
(
'$ref'
,
None
)
# We replace references to the self.root_ref with just '#' in the transform method
root_key
=
re
.
sub
(
r
'^#/\$defs/'
,
''
,
self
.
root_ref
)
result
.
update
(
self
.
defs
.
get
(
root_key
)
or
{})
return
result
def
transform
(
self
,
schema
:
JsonSchema
)
->
JsonSchema
:
# noqa C901
# Remove unnecessary keys
schema
.
pop
(
'title'
,
None
)
schema
.
pop
(
'$schema'
,
None
)
schema
.
pop
(
'discriminator'
,
None
)
default
=
schema
.
get
(
'default'
,
_sentinel
)
if
default
is
not
_sentinel
:
# the "default" keyword is not allowed in strict mode, but including it makes some Ollama models behave
# better, so we keep it around when not strict
if
self
.
strict
is
True
:
schema
.
pop
(
'default'
,
None
)
elif
self
.
strict
is
None
:
# pragma: no branch
self
.
is_strict_compatible
=
False
if
schema_ref
:=
schema
.
get
(
'$ref'
):
if
schema_ref
==
self
.
root_ref
:
schema
[
'$ref'
]
=
'#'
if
len
(
schema
)
>
1
:
# OpenAI Strict mode doesn't support siblings to "$ref", but _does_ allow siblings to "anyOf".
# So if there is a "description" field or any other extra info, we move the "$ref" into an "anyOf":
schema
[
'anyOf'
]
=
[{
'$ref'
:
schema
.
pop
(
'$ref'
)}]
# Track strict-incompatible keys
incompatible_values
:
dict
[
str
,
Any
]
=
{}
for
key
in
_STRICT_INCOMPATIBLE_KEYS
:
value
=
schema
.
get
(
key
,
_sentinel
)
if
value
is
not
_sentinel
:
incompatible_values
[
key
]
=
value
description
=
schema
.
get
(
'description'
)
if
incompatible_values
:
if
self
.
strict
is
True
:
notes
:
list
[
str
]
=
[]
for
key
,
value
in
incompatible_values
.
items
():
schema
.
pop
(
key
)
notes
.
append
(
f
'
{
key
}
=
{
value
}
'
)
notes_string
=
', '
.
join
(
notes
)
schema
[
'description'
]
=
notes_string
if
not
description
else
f
'
{
description
}
(
{
notes_string
}
)'
elif
self
.
strict
is
None
:
# pragma: no branch
self
.
is_strict_compatible
=
False
schema_type
=
schema
.
get
(
'type'
)
if
'oneOf'
in
schema
:
# OpenAI does not support oneOf in strict mode
if
self
.
strict
is
True
:
schema
[
'anyOf'
]
=
schema
.
pop
(
'oneOf'
)
else
:
self
.
is_strict_compatible
=
False
if
schema_type
==
'object'
:
if
self
.
strict
is
True
:
# additional properties are disallowed
schema
[
'additionalProperties'
]
=
False
# all properties are required
if
'properties'
not
in
schema
:
schema
[
'properties'
]
=
dict
[
str
,
Any
]()
schema
[
'required'
]
=
list
(
schema
[
'properties'
]
.
keys
())
elif
self
.
strict
is
None
:
if
(
schema
.
get
(
'additionalProperties'
)
is
not
False
or
'properties'
not
in
schema
or
'required'
not
in
schema
):
self
.
is_strict_compatible
=
False
else
:
required
=
schema
[
'required'
]
for
k
in
schema
[
'properties'
]
.
keys
():
if
k
not
in
required
:
self
.
is_strict_compatible
=
False
return
schema
anthropic_model_profile
anthropic_model_profile
(
model_name
:
str
,
)
->
ModelProfile
|
None
Get the model profile for an Anthropic model.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/anthropic.py
6
7
8
def
anthropic_model_profile
(
model_name
:
str
)
->
ModelProfile
|
None
:
"""Get the model profile for an Anthropic model."""
return
None
google_model_profile
google_model_profile
(
model_name
:
str
,
)
->
ModelProfile
|
None
Get the model profile for a Google model.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/google.py
11
12
13
14
15
16
17
def
google_model_profile
(
model_name
:
str
)
->
ModelProfile
|
None
:
"""Get the model profile for a Google model."""
return
ModelProfile
(
json_schema_transformer
=
GoogleJsonSchemaTransformer
,
supports_json_schema_output
=
True
,
supports_json_object_output
=
True
,
)
GoogleJsonSchemaTransformer
Bases:
JsonSchemaTransformer
Transforms the JSON Schema from Pydantic to be suitable for Gemini.
Gemini which
supports
a subset of OpenAPI v3.0.3.
Specifically:
* gemini doesn't allow the
title
keyword to be set
* gemini doesn't allow
$defs
— we need to inline the definitions where possible
Source code in
pydantic_ai_slim/pydantic_ai/profiles/google.py
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
class
GoogleJsonSchemaTransformer
(
JsonSchemaTransformer
):
"""Transforms the JSON Schema from Pydantic to be suitable for Gemini.
Gemini which [supports](https://ai.google.dev/gemini-api/docs/function-calling#function_declarations)
a subset of OpenAPI v3.0.3.
Specifically:
* gemini doesn't allow the `title` keyword to be set
* gemini doesn't allow `$defs` — we need to inline the definitions where possible
"""
def
__init__
(
self
,
schema
:
JsonSchema
,
*
,
strict
:
bool
|
None
=
None
):
super
()
.
__init__
(
schema
,
strict
=
strict
,
prefer_inlined_defs
=
True
,
simplify_nullable_unions
=
True
)
def
transform
(
self
,
schema
:
JsonSchema
)
->
JsonSchema
:
# Note: we need to remove `additionalProperties: False` since it is currently mishandled by Gemini
additional_properties
=
schema
.
pop
(
'additionalProperties'
,
None
)
# don't pop yet so it's included in the warning
if
additional_properties
:
original_schema
=
{
**
schema
,
'additionalProperties'
:
additional_properties
}
warnings
.
warn
(
'`additionalProperties` is not supported by Gemini; it will be removed from the tool JSON schema.'
f
' Full schema:
{
self
.
schema
}
\n\n
'
f
'Source of additionalProperties within the full schema:
{
original_schema
}
\n\n
'
'If this came from a field with a type like `dict[str, MyType]`, that field will always be empty.
\n\n
'
"If Google's APIs are updated to support this properly, please create an issue on the PydanticAI GitHub"
' and we will fix this behavior.'
,
UserWarning
,
)
schema
.
pop
(
'title'
,
None
)
schema
.
pop
(
'default'
,
None
)
schema
.
pop
(
'$schema'
,
None
)
if
(
const
:=
schema
.
pop
(
'const'
,
None
))
is
not
None
:
# Gemini doesn't support const, but it does support enum with a single value
schema
[
'enum'
]
=
[
const
]
schema
.
pop
(
'discriminator'
,
None
)
schema
.
pop
(
'examples'
,
None
)
# TODO: Should we use the trick from pydantic_ai.models.openai._OpenAIJsonSchema
#   where we add notes about these properties to the field description?
schema
.
pop
(
'exclusiveMaximum'
,
None
)
schema
.
pop
(
'exclusiveMinimum'
,
None
)
# Gemini only supports string enums, so we need to convert any enum values to strings.
# Pydantic will take care of transforming the transformed string values to the correct type.
if
enum
:=
schema
.
get
(
'enum'
):
schema
[
'type'
]
=
'string'
schema
[
'enum'
]
=
[
str
(
val
)
for
val
in
enum
]
type_
=
schema
.
get
(
'type'
)
if
'oneOf'
in
schema
and
'type'
not
in
schema
:
# pragma: no cover
# This gets hit when we have a discriminated union
# Gemini returns an API error in this case even though it says in its error message it shouldn't...
# Changing the oneOf to an anyOf prevents the API error and I think is functionally equivalent
schema
[
'anyOf'
]
=
schema
.
pop
(
'oneOf'
)
if
type_
==
'string'
and
(
fmt
:=
schema
.
pop
(
'format'
,
None
)):
description
=
schema
.
get
(
'description'
)
if
description
:
schema
[
'description'
]
=
f
'
{
description
}
(format:
{
fmt
}
)'
else
:
schema
[
'description'
]
=
f
'Format:
{
fmt
}
'
if
'$ref'
in
schema
:
raise
UserError
(
f
'Recursive `$ref`s in JSON Schema are not supported by Gemini:
{
schema
[
"$ref"
]
}
'
)
if
'prefixItems'
in
schema
:
# prefixItems is not currently supported in Gemini, so we convert it to items for best compatibility
prefix_items
=
schema
.
pop
(
'prefixItems'
)
items
=
schema
.
get
(
'items'
)
unique_items
=
[
items
]
if
items
is
not
None
else
[]
for
item
in
prefix_items
:
if
item
not
in
unique_items
:
unique_items
.
append
(
item
)
if
len
(
unique_items
)
>
1
:
# pragma: no cover
schema
[
'items'
]
=
{
'anyOf'
:
unique_items
}
elif
len
(
unique_items
)
==
1
:
# pragma: no branch
schema
[
'items'
]
=
unique_items
[
0
]
schema
.
setdefault
(
'minItems'
,
len
(
prefix_items
))
if
items
is
None
:
# pragma: no branch
schema
.
setdefault
(
'maxItems'
,
len
(
prefix_items
))
return
schema
meta_model_profile
meta_model_profile
(
model_name
:
str
)
->
ModelProfile
|
None
Get the model profile for a Meta model.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/meta.py
7
8
9
def
meta_model_profile
(
model_name
:
str
)
->
ModelProfile
|
None
:
"""Get the model profile for a Meta model."""
return
ModelProfile
(
json_schema_transformer
=
InlineDefsJsonSchemaTransformer
)
amazon_model_profile
amazon_model_profile
(
model_name
:
str
,
)
->
ModelProfile
|
None
Get the model profile for an Amazon model.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/amazon.py
7
8
9
def
amazon_model_profile
(
model_name
:
str
)
->
ModelProfile
|
None
:
"""Get the model profile for an Amazon model."""
return
ModelProfile
(
json_schema_transformer
=
InlineDefsJsonSchemaTransformer
)
deepseek_model_profile
deepseek_model_profile
(
model_name
:
str
,
)
->
ModelProfile
|
None
Get the model profile for a DeepSeek model.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/deepseek.py
6
7
8
def
deepseek_model_profile
(
model_name
:
str
)
->
ModelProfile
|
None
:
"""Get the model profile for a DeepSeek model."""
return
None
grok_model_profile
grok_model_profile
(
model_name
:
str
)
->
ModelProfile
|
None
Get the model profile for a Grok model.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/grok.py
6
7
8
def
grok_model_profile
(
model_name
:
str
)
->
ModelProfile
|
None
:
"""Get the model profile for a Grok model."""
return
None
mistral_model_profile
mistral_model_profile
(
model_name
:
str
,
)
->
ModelProfile
|
None
Get the model profile for a Mistral model.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/mistral.py
6
7
8
def
mistral_model_profile
(
model_name
:
str
)
->
ModelProfile
|
None
:
"""Get the model profile for a Mistral model."""
return
None
qwen_model_profile
qwen_model_profile
(
model_name
:
str
)
->
ModelProfile
|
None
Get the model profile for a Qwen model.
Source code in
pydantic_ai_slim/pydantic_ai/profiles/qwen.py
7
8
9
def
qwen_model_profile
(
model_name
:
str
)
->
ModelProfile
|
None
:
"""Get the model profile for a Qwen model."""
return
ModelProfile
(
json_schema_transformer
=
InlineDefsJsonSchemaTransformer
)