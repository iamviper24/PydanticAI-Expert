PydanticAI
pydantic/pydantic-ai
Introduction
Installation
Getting Help
Contributing
Troubleshooting
Upgrade Guide
Documentation
Documentation
Agents
Models
Models
OpenAI
Anthropic
Gemini
Google
Bedrock
Cohere
Groq
Mistral
Dependencies
Function Tools
Common Tools
Output
Messages and chat history
Unit testing
Debugging and Monitoring
Multi-agent Applications
Graphs
Evals
Image, Audio, Video & Document Input
Thinking
Direct Model Requests
MCP
MCP
Client
Server
MCP Run Python
A2A
Command Line Interface (CLI)
Examples
Examples
Pydantic Model
Weather agent
Bank support
SQL Generation
Flight booking
RAG
Stream markdown
Stream whales
Chat App with FastAPI
Question Graph
Slack Lead Qualifier with Modal
API Reference
API Reference
pydantic_ai.agent
pydantic_ai.tools
pydantic_ai.common_tools
pydantic_ai.output
pydantic_ai.result
pydantic_ai.messages
pydantic_ai.exceptions
pydantic_ai.settings
pydantic_ai.usage
pydantic_ai.mcp
pydantic_ai.format_as_xml
pydantic_ai.format_prompt
pydantic_ai.direct
pydantic_ai.models
pydantic_ai.models.openai
pydantic_ai.models.anthropic
pydantic_ai.models.anthropic
Table of contents
Setup
anthropic
LatestAnthropicModelNames
AnthropicModelName
AnthropicModelSettings
anthropic_metadata
anthropic_thinking
AnthropicModel
__init__
model_name
system
AnthropicStreamedResponse
model_name
timestamp
pydantic_ai.models.bedrock
pydantic_ai.models.cohere
pydantic_ai.models.gemini
pydantic_ai.models.google
pydantic_ai.models.groq
pydantic_ai.models.instrumented
pydantic_ai.models.mistral
pydantic_ai.models.test
pydantic_ai.models.function
pydantic_ai.models.fallback
pydantic_ai.models.wrapper
pydantic_ai.models.mcp_sampling
pydantic_ai.profiles
pydantic_ai.providers
pydantic_graph
pydantic_graph.nodes
pydantic_graph.persistence
pydantic_graph.mermaid
pydantic_graph.exceptions
pydantic_evals.dataset
pydantic_evals.evaluators
pydantic_evals.reporting
pydantic_evals.otel
pydantic_evals.generation
fasta2a
Table of contents
Setup
anthropic
LatestAnthropicModelNames
AnthropicModelName
AnthropicModelSettings
anthropic_metadata
anthropic_thinking
AnthropicModel
__init__
model_name
system
AnthropicStreamedResponse
model_name
timestamp
pydantic_ai.models.anthropic
Setup
For details on how to set up authentication with this model, see
model configuration for Anthropic
.
LatestAnthropicModelNames
module-attribute
LatestAnthropicModelNames
=
ModelParam
Latest Anthropic models.
AnthropicModelName
module-attribute
AnthropicModelName
=
Union
[
str
,
LatestAnthropicModelNames
]
Possible Anthropic model names.
Since Anthropic supports a variety of date-stamped models, we explicitly list the latest models but
allow any name in the type hints.
See
the Anthropic docs
for a full list.
AnthropicModelSettings
Bases:
ModelSettings
Settings used for an Anthropic model request.
Source code in
pydantic_ai_slim/pydantic_ai/models/anthropic.py
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
class
AnthropicModelSettings
(
ModelSettings
,
total
=
False
):
"""Settings used for an Anthropic model request."""
# ALL FIELDS MUST BE `anthropic_` PREFIXED SO YOU CAN MERGE THEM WITH OTHER MODELS.
anthropic_metadata
:
BetaMetadataParam
"""An object describing metadata about the request.
Contains `user_id`, an external identifier for the user who is associated with the request.
"""
anthropic_thinking
:
BetaThinkingConfigParam
"""Determine whether the model should generate a thinking block.
See [the Anthropic docs](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking) for more information.
"""
anthropic_metadata
instance-attribute
anthropic_metadata
:
BetaMetadataParam
An object describing metadata about the request.
Contains
user_id
, an external identifier for the user who is associated with the request.
anthropic_thinking
instance-attribute
anthropic_thinking
:
BetaThinkingConfigParam
Determine whether the model should generate a thinking block.
See
the Anthropic docs
for more information.
AnthropicModel
dataclass
Bases:
Model
A model that uses the Anthropic API.
Internally, this uses the
Anthropic Python client
to interact with the API.
Apart from
__init__
, all methods are private or match those of the base class.
Source code in
pydantic_ai_slim/pydantic_ai/models/anthropic.py
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
@dataclass
(
init
=
False
)
class
AnthropicModel
(
Model
):
"""A model that uses the Anthropic API.
Internally, this uses the [Anthropic Python client](https://github.com/anthropics/anthropic-sdk-python) to interact with the API.
Apart from `__init__`, all methods are private or match those of the base class.
"""
client
:
AsyncAnthropic
=
field
(
repr
=
False
)
_model_name
:
AnthropicModelName
=
field
(
repr
=
False
)
_system
:
str
=
field
(
default
=
'anthropic'
,
repr
=
False
)
def
__init__
(
self
,
model_name
:
AnthropicModelName
,
*
,
provider
:
Literal
[
'anthropic'
]
|
Provider
[
AsyncAnthropic
]
=
'anthropic'
,
profile
:
ModelProfileSpec
|
None
=
None
,
):
"""Initialize an Anthropic model.
Args:
model_name: The name of the Anthropic model to use. List of model names available
[here](https://docs.anthropic.com/en/docs/about-claude/models).
provider: The provider to use for the Anthropic API. Can be either the string 'anthropic' or an
instance of `Provider[AsyncAnthropic]`. If not provided, the other parameters will be used.
profile: The model profile to use. Defaults to a profile picked by the provider based on the model name.
"""
self
.
_model_name
=
model_name
if
isinstance
(
provider
,
str
):
provider
=
infer_provider
(
provider
)
self
.
client
=
provider
.
client
self
.
_profile
=
profile
or
provider
.
model_profile
@property
def
base_url
(
self
)
->
str
:
return
str
(
self
.
client
.
base_url
)
async
def
request
(
self
,
messages
:
list
[
ModelMessage
],
model_settings
:
ModelSettings
|
None
,
model_request_parameters
:
ModelRequestParameters
,
)
->
ModelResponse
:
check_allow_model_requests
()
response
=
await
self
.
_messages_create
(
messages
,
False
,
cast
(
AnthropicModelSettings
,
model_settings
or
{}),
model_request_parameters
)
model_response
=
self
.
_process_response
(
response
)
model_response
.
usage
.
requests
=
1
return
model_response
@asynccontextmanager
async
def
request_stream
(
self
,
messages
:
list
[
ModelMessage
],
model_settings
:
ModelSettings
|
None
,
model_request_parameters
:
ModelRequestParameters
,
)
->
AsyncIterator
[
StreamedResponse
]:
check_allow_model_requests
()
response
=
await
self
.
_messages_create
(
messages
,
True
,
cast
(
AnthropicModelSettings
,
model_settings
or
{}),
model_request_parameters
)
async
with
response
:
yield
await
self
.
_process_streamed_response
(
response
)
@property
def
model_name
(
self
)
->
AnthropicModelName
:
"""The model name."""
return
self
.
_model_name
@property
def
system
(
self
)
->
str
:
"""The system / model provider."""
return
self
.
_system
@overload
async
def
_messages_create
(
self
,
messages
:
list
[
ModelMessage
],
stream
:
Literal
[
True
],
model_settings
:
AnthropicModelSettings
,
model_request_parameters
:
ModelRequestParameters
,
)
->
AsyncStream
[
BetaRawMessageStreamEvent
]:
pass
@overload
async
def
_messages_create
(
self
,
messages
:
list
[
ModelMessage
],
stream
:
Literal
[
False
],
model_settings
:
AnthropicModelSettings
,
model_request_parameters
:
ModelRequestParameters
,
)
->
BetaMessage
:
pass
async
def
_messages_create
(
self
,
messages
:
list
[
ModelMessage
],
stream
:
bool
,
model_settings
:
AnthropicModelSettings
,
model_request_parameters
:
ModelRequestParameters
,
)
->
BetaMessage
|
AsyncStream
[
BetaRawMessageStreamEvent
]:
# standalone function to make it easier to override
tools
=
self
.
_get_tools
(
model_request_parameters
)
tool_choice
:
BetaToolChoiceParam
|
None
if
not
tools
:
tool_choice
=
None
else
:
if
not
model_request_parameters
.
allow_text_output
:
tool_choice
=
{
'type'
:
'any'
}
else
:
tool_choice
=
{
'type'
:
'auto'
}
if
(
allow_parallel_tool_calls
:=
model_settings
.
get
(
'parallel_tool_calls'
))
is
not
None
:
tool_choice
[
'disable_parallel_tool_use'
]
=
not
allow_parallel_tool_calls
system_prompt
,
anthropic_messages
=
await
self
.
_map_message
(
messages
)
try
:
extra_headers
=
model_settings
.
get
(
'extra_headers'
,
{})
extra_headers
.
setdefault
(
'User-Agent'
,
get_user_agent
())
return
await
self
.
client
.
beta
.
messages
.
create
(
max_tokens
=
model_settings
.
get
(
'max_tokens'
,
4096
),
system
=
system_prompt
or
NOT_GIVEN
,
messages
=
anthropic_messages
,
model
=
self
.
_model_name
,
tools
=
tools
or
NOT_GIVEN
,
tool_choice
=
tool_choice
or
NOT_GIVEN
,
stream
=
stream
,
thinking
=
model_settings
.
get
(
'anthropic_thinking'
,
NOT_GIVEN
),
stop_sequences
=
model_settings
.
get
(
'stop_sequences'
,
NOT_GIVEN
),
temperature
=
model_settings
.
get
(
'temperature'
,
NOT_GIVEN
),
top_p
=
model_settings
.
get
(
'top_p'
,
NOT_GIVEN
),
timeout
=
model_settings
.
get
(
'timeout'
,
NOT_GIVEN
),
metadata
=
model_settings
.
get
(
'anthropic_metadata'
,
NOT_GIVEN
),
extra_headers
=
extra_headers
,
extra_body
=
model_settings
.
get
(
'extra_body'
),
)
except
APIStatusError
as
e
:
if
(
status_code
:=
e
.
status_code
)
>=
400
:
raise
ModelHTTPError
(
status_code
=
status_code
,
model_name
=
self
.
model_name
,
body
=
e
.
body
)
from
e
raise
# pragma: lax no cover
def
_process_response
(
self
,
response
:
BetaMessage
)
->
ModelResponse
:
"""Process a non-streamed response, and prepare a message to return."""
items
:
list
[
ModelResponsePart
]
=
[]
for
item
in
response
.
content
:
if
isinstance
(
item
,
BetaTextBlock
):
items
.
append
(
TextPart
(
content
=
item
.
text
))
elif
isinstance
(
item
,
BetaRedactedThinkingBlock
):
# pragma: no cover
warnings
.
warn
(
'PydanticAI currently does not handle redacted thinking blocks. '
'If you have a suggestion on how we should handle them, please open an issue.'
,
UserWarning
,
)
elif
isinstance
(
item
,
BetaThinkingBlock
):
items
.
append
(
ThinkingPart
(
content
=
item
.
thinking
,
signature
=
item
.
signature
))
else
:
assert
isinstance
(
item
,
BetaToolUseBlock
),
f
'unexpected item type
{
type
(
item
)
}
'
items
.
append
(
ToolCallPart
(
tool_name
=
item
.
name
,
args
=
cast
(
dict
[
str
,
Any
],
item
.
input
),
tool_call_id
=
item
.
id
,
)
)
return
ModelResponse
(
items
,
usage
=
_map_usage
(
response
),
model_name
=
response
.
model
,
vendor_id
=
response
.
id
)
async
def
_process_streamed_response
(
self
,
response
:
AsyncStream
[
BetaRawMessageStreamEvent
])
->
StreamedResponse
:
peekable_response
=
_utils
.
PeekableAsyncStream
(
response
)
first_chunk
=
await
peekable_response
.
peek
()
if
isinstance
(
first_chunk
,
_utils
.
Unset
):
raise
UnexpectedModelBehavior
(
'Streamed response ended without content or tool calls'
)
# pragma: no cover
# Since Anthropic doesn't provide a timestamp in the message, we'll use the current time
timestamp
=
datetime
.
now
(
tz
=
timezone
.
utc
)
return
AnthropicStreamedResponse
(
_model_name
=
self
.
_model_name
,
_response
=
peekable_response
,
_timestamp
=
timestamp
)
def
_get_tools
(
self
,
model_request_parameters
:
ModelRequestParameters
)
->
list
[
BetaToolParam
]:
tools
=
[
self
.
_map_tool_definition
(
r
)
for
r
in
model_request_parameters
.
function_tools
]
if
model_request_parameters
.
output_tools
:
tools
+=
[
self
.
_map_tool_definition
(
r
)
for
r
in
model_request_parameters
.
output_tools
]
return
tools
async
def
_map_message
(
self
,
messages
:
list
[
ModelMessage
])
->
tuple
[
str
,
list
[
BetaMessageParam
]]:
# noqa: C901
"""Just maps a `pydantic_ai.Message` to a `anthropic.types.MessageParam`."""
system_prompt_parts
:
list
[
str
]
=
[]
anthropic_messages
:
list
[
BetaMessageParam
]
=
[]
for
m
in
messages
:
if
isinstance
(
m
,
ModelRequest
):
user_content_params
:
list
[
BetaContentBlockParam
]
=
[]
for
request_part
in
m
.
parts
:
if
isinstance
(
request_part
,
SystemPromptPart
):
system_prompt_parts
.
append
(
request_part
.
content
)
elif
isinstance
(
request_part
,
UserPromptPart
):
async
for
content
in
self
.
_map_user_prompt
(
request_part
):
user_content_params
.
append
(
content
)
elif
isinstance
(
request_part
,
ToolReturnPart
):
tool_result_block_param
=
BetaToolResultBlockParam
(
tool_use_id
=
_guard_tool_call_id
(
t
=
request_part
),
type
=
'tool_result'
,
content
=
request_part
.
model_response_str
(),
is_error
=
False
,
)
user_content_params
.
append
(
tool_result_block_param
)
elif
isinstance
(
request_part
,
RetryPromptPart
):
# pragma: no branch
if
request_part
.
tool_name
is
None
:
text
=
request_part
.
model_response
()
# pragma: no cover
retry_param
=
BetaTextBlockParam
(
type
=
'text'
,
text
=
text
)
# pragma: no cover
else
:
retry_param
=
BetaToolResultBlockParam
(
tool_use_id
=
_guard_tool_call_id
(
t
=
request_part
),
type
=
'tool_result'
,
content
=
request_part
.
model_response
(),
is_error
=
True
,
)
user_content_params
.
append
(
retry_param
)
if
len
(
user_content_params
)
>
0
:
anthropic_messages
.
append
(
BetaMessageParam
(
role
=
'user'
,
content
=
user_content_params
))
elif
isinstance
(
m
,
ModelResponse
):
assistant_content_params
:
list
[
BetaTextBlockParam
|
BetaToolUseBlockParam
|
BetaThinkingBlockParam
]
=
[]
for
response_part
in
m
.
parts
:
if
isinstance
(
response_part
,
TextPart
):
if
response_part
.
content
:
# Only add non-empty text
assistant_content_params
.
append
(
BetaTextBlockParam
(
text
=
response_part
.
content
,
type
=
'text'
))
elif
isinstance
(
response_part
,
ThinkingPart
):
# NOTE: We only send thinking part back for Anthropic, otherwise they raise an error.
if
response_part
.
signature
is
not
None
:
# pragma: no branch
assistant_content_params
.
append
(
BetaThinkingBlockParam
(
thinking
=
response_part
.
content
,
signature
=
response_part
.
signature
,
type
=
'thinking'
)
)
else
:
tool_use_block_param
=
BetaToolUseBlockParam
(
id
=
_guard_tool_call_id
(
t
=
response_part
),
type
=
'tool_use'
,
name
=
response_part
.
tool_name
,
input
=
response_part
.
args_as_dict
(),
)
assistant_content_params
.
append
(
tool_use_block_param
)
if
len
(
assistant_content_params
)
>
0
:
anthropic_messages
.
append
(
BetaMessageParam
(
role
=
'assistant'
,
content
=
assistant_content_params
))
else
:
assert_never
(
m
)
system_prompt
=
'
\n\n
'
.
join
(
system_prompt_parts
)
if
instructions
:=
self
.
_get_instructions
(
messages
):
system_prompt
=
f
'
{
instructions
}
\n\n
{
system_prompt
}
'
return
system_prompt
,
anthropic_messages
@staticmethod
async
def
_map_user_prompt
(
part
:
UserPromptPart
,
)
->
AsyncGenerator
[
BetaContentBlockParam
]:
if
isinstance
(
part
.
content
,
str
):
if
part
.
content
:
# Only yield non-empty text
yield
BetaTextBlockParam
(
text
=
part
.
content
,
type
=
'text'
)
else
:
for
item
in
part
.
content
:
if
isinstance
(
item
,
str
):
if
item
:
# Only yield non-empty text
yield
BetaTextBlockParam
(
text
=
item
,
type
=
'text'
)
elif
isinstance
(
item
,
BinaryContent
):
if
item
.
is_image
:
yield
BetaImageBlockParam
(
source
=
{
'data'
:
io
.
BytesIO
(
item
.
data
),
'media_type'
:
item
.
media_type
,
'type'
:
'base64'
},
# type: ignore
type
=
'image'
,
)
elif
item
.
media_type
==
'application/pdf'
:
yield
BetaBase64PDFBlockParam
(
source
=
BetaBase64PDFSourceParam
(
data
=
io
.
BytesIO
(
item
.
data
),
media_type
=
'application/pdf'
,
type
=
'base64'
,
),
type
=
'document'
,
)
else
:
raise
RuntimeError
(
'Only images and PDFs are supported for binary content'
)
elif
isinstance
(
item
,
ImageUrl
):
yield
BetaImageBlockParam
(
source
=
{
'type'
:
'url'
,
'url'
:
item
.
url
},
type
=
'image'
)
elif
isinstance
(
item
,
DocumentUrl
):
if
item
.
media_type
==
'application/pdf'
:
yield
BetaBase64PDFBlockParam
(
source
=
{
'url'
:
item
.
url
,
'type'
:
'url'
},
type
=
'document'
)
elif
item
.
media_type
==
'text/plain'
:
downloaded_item
=
await
download_item
(
item
,
data_format
=
'text'
)
yield
BetaBase64PDFBlockParam
(
source
=
BetaPlainTextSourceParam
(
data
=
downloaded_item
[
'data'
],
media_type
=
item
.
media_type
,
type
=
'text'
),
type
=
'document'
,
)
else
:
# pragma: no cover
raise
RuntimeError
(
f
'Unsupported media type:
{
item
.
media_type
}
'
)
else
:
raise
RuntimeError
(
f
'Unsupported content type:
{
type
(
item
)
}
'
)
# pragma: no cover
@staticmethod
def
_map_tool_definition
(
f
:
ToolDefinition
)
->
BetaToolParam
:
return
{
'name'
:
f
.
name
,
'description'
:
f
.
description
or
''
,
'input_schema'
:
f
.
parameters_json_schema
,
}
__init__
__init__
(
model_name
:
AnthropicModelName
,
*
,
provider
:
(
Literal
[
"anthropic"
]
|
Provider
[
AsyncAnthropic
]
)
=
"anthropic"
,
profile
:
ModelProfileSpec
|
None
=
None
)
Initialize an Anthropic model.
Parameters:
Name
Type
Description
Default
model_name
AnthropicModelName
The name of the Anthropic model to use. List of model names available
here
.
required
provider
Literal
['anthropic'] |
Provider
[
AsyncAnthropic
]
The provider to use for the Anthropic API. Can be either the string 'anthropic' or an
instance of
Provider[AsyncAnthropic]
. If not provided, the other parameters will be used.
'anthropic'
profile
ModelProfileSpec
| None
The model profile to use. Defaults to a profile picked by the provider based on the model name.
None
Source code in
pydantic_ai_slim/pydantic_ai/models/anthropic.py
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
def
__init__
(
self
,
model_name
:
AnthropicModelName
,
*
,
provider
:
Literal
[
'anthropic'
]
|
Provider
[
AsyncAnthropic
]
=
'anthropic'
,
profile
:
ModelProfileSpec
|
None
=
None
,
):
"""Initialize an Anthropic model.
Args:
model_name: The name of the Anthropic model to use. List of model names available
[here](https://docs.anthropic.com/en/docs/about-claude/models).
provider: The provider to use for the Anthropic API. Can be either the string 'anthropic' or an
instance of `Provider[AsyncAnthropic]`. If not provided, the other parameters will be used.
profile: The model profile to use. Defaults to a profile picked by the provider based on the model name.
"""
self
.
_model_name
=
model_name
if
isinstance
(
provider
,
str
):
provider
=
infer_provider
(
provider
)
self
.
client
=
provider
.
client
self
.
_profile
=
profile
or
provider
.
model_profile
model_name
property
model_name
:
AnthropicModelName
The model name.
system
property
system
:
str
The system / model provider.
AnthropicStreamedResponse
dataclass
Bases:
StreamedResponse
Implementation of
StreamedResponse
for Anthropic models.
Source code in
pydantic_ai_slim/pydantic_ai/models/anthropic.py
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
@dataclass
class
AnthropicStreamedResponse
(
StreamedResponse
):
"""Implementation of `StreamedResponse` for Anthropic models."""
_model_name
:
AnthropicModelName
_response
:
AsyncIterable
[
BetaRawMessageStreamEvent
]
_timestamp
:
datetime
async
def
_get_event_iterator
(
self
)
->
AsyncIterator
[
ModelResponseStreamEvent
]:
current_block
:
BetaContentBlock
|
None
=
None
async
for
event
in
self
.
_response
:
self
.
_usage
+=
_map_usage
(
event
)
if
isinstance
(
event
,
BetaRawContentBlockStartEvent
):
current_block
=
event
.
content_block
if
isinstance
(
current_block
,
BetaTextBlock
)
and
current_block
.
text
:
yield
self
.
_parts_manager
.
handle_text_delta
(
vendor_part_id
=
'content'
,
content
=
current_block
.
text
)
elif
isinstance
(
current_block
,
BetaThinkingBlock
):
yield
self
.
_parts_manager
.
handle_thinking_delta
(
vendor_part_id
=
'thinking'
,
content
=
current_block
.
thinking
,
signature
=
current_block
.
signature
,
)
elif
isinstance
(
current_block
,
BetaToolUseBlock
):
maybe_event
=
self
.
_parts_manager
.
handle_tool_call_delta
(
vendor_part_id
=
current_block
.
id
,
tool_name
=
current_block
.
name
,
args
=
cast
(
dict
[
str
,
Any
],
current_block
.
input
)
or
None
,
tool_call_id
=
current_block
.
id
,
)
if
maybe_event
is
not
None
:
# pragma: no branch
yield
maybe_event
elif
isinstance
(
event
,
BetaRawContentBlockDeltaEvent
):
if
isinstance
(
event
.
delta
,
BetaTextDelta
):
yield
self
.
_parts_manager
.
handle_text_delta
(
vendor_part_id
=
'content'
,
content
=
event
.
delta
.
text
)
elif
isinstance
(
event
.
delta
,
BetaThinkingDelta
):
yield
self
.
_parts_manager
.
handle_thinking_delta
(
vendor_part_id
=
'thinking'
,
content
=
event
.
delta
.
thinking
)
elif
isinstance
(
event
.
delta
,
BetaSignatureDelta
):
yield
self
.
_parts_manager
.
handle_thinking_delta
(
vendor_part_id
=
'thinking'
,
signature
=
event
.
delta
.
signature
)
elif
(
current_block
and
event
.
delta
.
type
==
'input_json_delta'
and
isinstance
(
current_block
,
BetaToolUseBlock
)
):
# pragma: no branch
maybe_event
=
self
.
_parts_manager
.
handle_tool_call_delta
(
vendor_part_id
=
current_block
.
id
,
tool_name
=
''
,
args
=
event
.
delta
.
partial_json
,
tool_call_id
=
current_block
.
id
,
)
if
maybe_event
is
not
None
:
# pragma: no branch
yield
maybe_event
elif
isinstance
(
event
,
(
BetaRawContentBlockStopEvent
,
BetaRawMessageStopEvent
)):
current_block
=
None
@property
def
model_name
(
self
)
->
AnthropicModelName
:
"""Get the model name of the response."""
return
self
.
_model_name
@property
def
timestamp
(
self
)
->
datetime
:
"""Get the timestamp of the response."""
return
self
.
_timestamp
model_name
property
model_name
:
AnthropicModelName
Get the model name of the response.
timestamp
property
timestamp
:
datetime
Get the timestamp of the response.